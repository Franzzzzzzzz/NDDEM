<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NDDEM: cereal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NDDEM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cereal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>in certain simple scenarios. They should probably not be used if maximizing performance is the main objective.  
<a href="namespacecereal.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecereal_1_1base64"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1base64.html">base64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1base__class__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1base__class__detail.html">base_class_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1bitset__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1bitset__detail.html">bitset_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1boost__variant__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1boost__variant__detail.html">boost_variant_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1common__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1common__detail.html">common_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1memory__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1memory__detail.html">memory_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1polymorphic__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1polymorphic__detail.html">polymorphic_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1portable__binary__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1portable__binary__detail.html">portable_binary_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1queue__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1queue__detail.html">queue_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1rapidxml"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1rapidxml.html">rapidxml</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1set__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1set__detail.html">set_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1stack__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1stack__detail.html">stack_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html">traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1tuple__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1tuple__detail.html">tuple_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1unordered__set__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1unordered__set__detail.html">unordered_set_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1util.html">util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1variant__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1variant__detail.html">variant_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1xml__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1xml__detail.html">xml_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1LoadAndConstruct.html">LoadAndConstruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that allows cereal to load smart pointers to types that have no default constructor.  <a href="structcereal_1_1LoadAndConstruct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1construct.html">construct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to construct types with no default constructor.  <a href="classcereal_1_1construct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1access.html">access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that can be made a friend to give cereal access to non public functions.  <a href="classcereal_1_1access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1BinaryOutputArchive.html">BinaryOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data in a compact binary representation.  <a href="classcereal_1_1BinaryOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1BinaryInputArchive.html">BinaryInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data saved using <a class="el" href="classcereal_1_1BinaryOutputArchive.html" title="An output archive designed to save data in a compact binary representation.">BinaryOutputArchive</a>.  <a href="classcereal_1_1BinaryInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1RapidJSONException.html">RapidJSONException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when rapidjson fails an internal assertion.  <a href="structcereal_1_1RapidJSONException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data to JSON.  <a href="classcereal_1_1JSONOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data from JSON.  <a href="classcereal_1_1JSONInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1PortableBinaryOutputArchive.html">PortableBinaryOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data in a compact binary representation portable over different architectures.  <a href="classcereal_1_1PortableBinaryOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1PortableBinaryInputArchive.html">PortableBinaryInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data saved using <a class="el" href="classcereal_1_1PortableBinaryOutputArchive.html" title="An output archive designed to save data in a compact binary representation portable over different ar...">PortableBinaryOutputArchive</a>.  <a href="classcereal_1_1PortableBinaryInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data to XML.  <a href="classcereal_1_1XMLOutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to load data from XML.  <a href="classcereal_1_1XMLInputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1OutputArchive.html">OutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base output archive class.  <a href="classcereal_1_1OutputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1InputArchive.html">InputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base input archive class.  <a href="classcereal_1_1InputArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception class thrown when things go wrong at runtime.  <a href="structcereal_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For holding name value pairs.  <a href="classcereal_1_1NameValuePair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around data that can be serialized in a binary fashion.  <a href="structcereal_1_1BinaryData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around data that should be serialized after all non-deferred data.  <a href="classcereal_1_1DeferredData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around size metadata.  <a href="classcereal_1_1SizeTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1MapItem.html">MapItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a key and value for serializing data into maps.  <a href="structcereal_1_1MapItem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1specialize.html">specialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to disambiguate cases where cereal cannot detect a unique way of serializing a class.  <a href="structcereal_1_1specialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1base__class.html">base_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a derived class to its non-virtual base class in a way that safely supports abstract classes.  <a href="structcereal_1_1base__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1virtual__base__class.html">virtual_base_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a derived class to its virtual base class in a way that allows cereal to track inheritance.  <a href="structcereal_1_1virtual__base__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aba657f7ef148daa498dc4fa9e579b01e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aba657f7ef148daa498dc4fa9e579b01e">size_type</a> = <a class="el" href="macros_8hpp.html#a2ad098b163a5f4829eb00fd7fb0b408d">CEREAL_SIZE_TYPE</a></td></tr>
<tr class="memdesc:aba657f7ef148daa498dc4fa9e579b01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size type used by cereal.  <a href="namespacecereal.html#aba657f7ef148daa498dc4fa9e579b01e">More...</a><br /></td></tr>
<tr class="separator:aba657f7ef148daa498dc4fa9e579b01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a95185aa9f39e4ac382bb6631beb68a67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a95185aa9f39e4ac382bb6631beb68a67">Flags</a> { <a class="el" href="namespacecereal.html#a95185aa9f39e4ac382bb6631beb68a67ae264e38ef1170510fbdfa5f1e4d5c532">AllowEmptyClassElision</a> = 1
 }</td></tr>
<tr class="memdesc:a95185aa9f39e4ac382bb6631beb68a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special flags for archives.  <a href="namespacecereal.html#a95185aa9f39e4ac382bb6631beb68a67">More...</a><br /></td></tr>
<tr class="separator:a95185aa9f39e4ac382bb6631beb68a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28bb730353e53b3066cc679e63bb108"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1specialize.html#ac28bb730353e53b3066cc679e63bb108">specialization</a> </td></tr>
<tr class="separator:ac28bb730353e53b3066cc679e63bb108"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8aeb7b414512d91291d759aaa284a8c2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8aeb7b414512d91291d759aaa284a8c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a8aeb7b414512d91291d759aaa284a8c2">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1BinaryOutputArchive.html">BinaryOutputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;t)</td></tr>
<tr class="memdesc:a8aeb7b414512d91291d759aaa284a8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to binary.  <a href="namespacecereal.html#a8aeb7b414512d91291d759aaa284a8c2">More...</a><br /></td></tr>
<tr class="separator:a8aeb7b414512d91291d759aaa284a8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9235c50bdb3961865274a086dda972"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4d9235c50bdb3961865274a086dda972"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4d9235c50bdb3961865274a086dda972">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1BinaryInputArchive.html">BinaryInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:a4d9235c50bdb3961865274a086dda972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from binary.  <a href="namespacecereal.html#a4d9235c50bdb3961865274a086dda972">More...</a><br /></td></tr>
<tr class="separator:a4d9235c50bdb3961865274a086dda972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a64ec0a04e5dc57a58de5e78b5a87b8d3">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing NVP types to binary.  <a href="namespacecereal.html#a64ec0a04e5dc57a58de5e78b5a87b8d3">More...</a><br /></td></tr>
<tr class="separator:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac5fb9b1468920e7e23cb2817e65fed4a">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing SizeTags to binary.  <a href="namespacecereal.html#ac5fb9b1468920e7e23cb2817e65fed4a">More...</a><br /></td></tr>
<tr class="separator:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189662781a0f3b710901f892d87792d5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a189662781a0f3b710901f892d87792d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a189662781a0f3b710901f892d87792d5">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1BinaryOutputArchive.html">BinaryOutputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;bd)</td></tr>
<tr class="memdesc:a189662781a0f3b710901f892d87792d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving binary data.  <a href="namespacecereal.html#a189662781a0f3b710901f892d87792d5">More...</a><br /></td></tr>
<tr class="separator:a189662781a0f3b710901f892d87792d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8577c2834d64922e9460cad77f9a3ac"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af8577c2834d64922e9460cad77f9a3ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af8577c2834d64922e9460cad77f9a3ac">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1BinaryInputArchive.html">BinaryInputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; &amp;bd)</td></tr>
<tr class="memdesc:af8577c2834d64922e9460cad77f9a3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading binary data.  <a href="namespacecereal.html#af8577c2834d64922e9460cad77f9a3ac">More...</a><br /></td></tr>
<tr class="separator:af8577c2834d64922e9460cad77f9a3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac267b8915a13f4433fc25aa9d310ee40"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac267b8915a13f4433fc25aa9d310ee40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac267b8915a13f4433fc25aa9d310ee40">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:ac267b8915a13f4433fc25aa9d310ee40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for JSON archives.  <a href="namespacecereal.html#ac267b8915a13f4433fc25aa9d310ee40">More...</a><br /></td></tr>
<tr class="separator:ac267b8915a13f4433fc25aa9d310ee40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ae77f745fd34dd83fa6543e0fa478bdfa">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for JSON archives.  <a href="namespacecereal.html#ae77f745fd34dd83fa6543e0fa478bdfa">More...</a><br /></td></tr>
<tr class="separator:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bec173adc6146ecc712921c2d257ade"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3bec173adc6146ecc712921c2d257ade"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a3bec173adc6146ecc712921c2d257ade">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a3bec173adc6146ecc712921c2d257ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for JSON archives.  <a href="namespacecereal.html#a3bec173adc6146ecc712921c2d257ade">More...</a><br /></td></tr>
<tr class="separator:a3bec173adc6146ecc712921c2d257ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99326c431920835d61e5bfc51b865f22"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a99326c431920835d61e5bfc51b865f22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a99326c431920835d61e5bfc51b865f22">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a99326c431920835d61e5bfc51b865f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for JSON archives.  <a href="namespacecereal.html#a99326c431920835d61e5bfc51b865f22">More...</a><br /></td></tr>
<tr class="separator:a99326c431920835d61e5bfc51b865f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4eb0997ec3815e2be77c35351d02cf7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4eb0997ec3815e2be77c35351d02cf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ab4eb0997ec3815e2be77c35351d02cf7">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:ab4eb0997ec3815e2be77c35351d02cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for JSON archives.  <a href="namespacecereal.html#ab4eb0997ec3815e2be77c35351d02cf7">More...</a><br /></td></tr>
<tr class="separator:ab4eb0997ec3815e2be77c35351d02cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff01a6c38b02073beb88b56f80b0ba7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6ff01a6c38b02073beb88b56f80b0ba7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a6ff01a6c38b02073beb88b56f80b0ba7">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a6ff01a6c38b02073beb88b56f80b0ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for JSON archives.  <a href="namespacecereal.html#a6ff01a6c38b02073beb88b56f80b0ba7">More...</a><br /></td></tr>
<tr class="separator:a6ff01a6c38b02073beb88b56f80b0ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c0c3b1ea7aadc84af34b815bfad6a6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae0c0c3b1ea7aadc84af34b815bfad6a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ae0c0c3b1ea7aadc84af34b815bfad6a6">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:ae0c0c3b1ea7aadc84af34b815bfad6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for JSON archives.  <a href="namespacecereal.html#ae0c0c3b1ea7aadc84af34b815bfad6a6">More...</a><br /></td></tr>
<tr class="separator:ae0c0c3b1ea7aadc84af34b815bfad6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae425e0a66c44b7d39b16d0a6a7f0d9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7ae425e0a66c44b7d39b16d0a6a7f0d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a7ae425e0a66c44b7d39b16d0a6a7f0d9">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a7ae425e0a66c44b7d39b16d0a6a7f0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for JSON archives.  <a href="namespacecereal.html#a7ae425e0a66c44b7d39b16d0a6a7f0d9">More...</a><br /></td></tr>
<tr class="separator:a7ae425e0a66c44b7d39b16d0a6a7f0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7ec98da774f9e0af596620859d8ccb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5f7ec98da774f9e0af596620859d8ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a5f7ec98da774f9e0af596620859d8ccb">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a5f7ec98da774f9e0af596620859d8ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for JSON archives.  <a href="namespacecereal.html#a5f7ec98da774f9e0af596620859d8ccb">More...</a><br /></td></tr>
<tr class="separator:a5f7ec98da774f9e0af596620859d8ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accec39647fd17ad5470e42a5c371701c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:accec39647fd17ad5470e42a5c371701c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#accec39647fd17ad5470e42a5c371701c">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:accec39647fd17ad5470e42a5c371701c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for JSON archives.  <a href="namespacecereal.html#accec39647fd17ad5470e42a5c371701c">More...</a><br /></td></tr>
<tr class="separator:accec39647fd17ad5470e42a5c371701c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92526cf5d3f4a642d918a027d2e4567"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab92526cf5d3f4a642d918a027d2e4567"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ab92526cf5d3f4a642d918a027d2e4567">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:ab92526cf5d3f4a642d918a027d2e4567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for JSON archives.  <a href="namespacecereal.html#ab92526cf5d3f4a642d918a027d2e4567">More...</a><br /></td></tr>
<tr class="separator:ab92526cf5d3f4a642d918a027d2e4567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb582097a98c0558c1a6b3cf0ef52270"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb582097a98c0558c1a6b3cf0ef52270"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#acb582097a98c0558c1a6b3cf0ef52270">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:acb582097a98c0558c1a6b3cf0ef52270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for JSON archives.  <a href="namespacecereal.html#acb582097a98c0558c1a6b3cf0ef52270">More...</a><br /></td></tr>
<tr class="separator:acb582097a98c0558c1a6b3cf0ef52270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2924cd871a88c20023171f74a68d39"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, JSONOutputArchive &gt;::value, !traits::has_minimal_output_serialization&lt; T, JSONOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:aba2924cd871a88c20023171f74a68d39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aba2924cd871a88c20023171f74a68d39">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:aba2924cd871a88c20023171f74a68d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for JSON archives (except minimal types)  <a href="namespacecereal.html#aba2924cd871a88c20023171f74a68d39">More...</a><br /></td></tr>
<tr class="separator:aba2924cd871a88c20023171f74a68d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88fce78fe97297ab4d22a607fee1e07"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, JSONInputArchive &gt;::value, !traits::has_minimal_input_serialization&lt; T, JSONInputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:af88fce78fe97297ab4d22a607fee1e07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af88fce78fe97297ab4d22a607fee1e07">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:af88fce78fe97297ab4d22a607fee1e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for JSON archives.  <a href="namespacecereal.html#af88fce78fe97297ab4d22a607fee1e07">More...</a><br /></td></tr>
<tr class="separator:af88fce78fe97297ab4d22a607fee1e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6adc568591c0a525f2c16ea5912c5b"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, JSONOutputArchive &gt;::value, !traits::has_minimal_output_serialization&lt; T, JSONOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:abb6adc568591c0a525f2c16ea5912c5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#abb6adc568591c0a525f2c16ea5912c5b">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:abb6adc568591c0a525f2c16ea5912c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for JSON archives (except minimal types)  <a href="namespacecereal.html#abb6adc568591c0a525f2c16ea5912c5b">More...</a><br /></td></tr>
<tr class="separator:abb6adc568591c0a525f2c16ea5912c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdc10b14dce9340a8df6cb18ac74554"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, JSONInputArchive &gt;::value, !traits::has_minimal_input_serialization&lt; T, JSONInputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a5cdc10b14dce9340a8df6cb18ac74554"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a5cdc10b14dce9340a8df6cb18ac74554">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a5cdc10b14dce9340a8df6cb18ac74554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for JSON archives.  <a href="namespacecereal.html#a5cdc10b14dce9340a8df6cb18ac74554">More...</a><br /></td></tr>
<tr class="separator:a5cdc10b14dce9340a8df6cb18ac74554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956c4c0578baf265811497c965c4a382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a956c4c0578baf265811497c965c4a382">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, std::nullptr_t <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a956c4c0578baf265811497c965c4a382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for arithmetic types for JSON archives.  <a href="namespacecereal.html#a956c4c0578baf265811497c965c4a382">More...</a><br /></td></tr>
<tr class="separator:a956c4c0578baf265811497c965c4a382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef075a9d94a926df8ba17689914233e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aef075a9d94a926df8ba17689914233e2">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, std::nullptr_t <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:aef075a9d94a926df8ba17689914233e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for arithmetic types for JSON archives.  <a href="namespacecereal.html#aef075a9d94a926df8ba17689914233e2">More...</a><br /></td></tr>
<tr class="separator:aef075a9d94a926df8ba17689914233e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67f92a71f4318dd69e6dec516fe57dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ad67f92a71f4318dd69e6dec516fe57dd">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, std::nullptr_t <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:ad67f92a71f4318dd69e6dec516fe57dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for arithmetic types for JSON archives.  <a href="namespacecereal.html#ad67f92a71f4318dd69e6dec516fe57dd">More...</a><br /></td></tr>
<tr class="separator:ad67f92a71f4318dd69e6dec516fe57dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9198bda1f28453a9ead2f8999e5fb449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a9198bda1f28453a9ead2f8999e5fb449">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, std::nullptr_t <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a9198bda1f28453a9ead2f8999e5fb449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for arithmetic types for JSON archives.  <a href="namespacecereal.html#a9198bda1f28453a9ead2f8999e5fb449">More...</a><br /></td></tr>
<tr class="separator:a9198bda1f28453a9ead2f8999e5fb449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacd1c15f7ed1793453e56a675bd0a78"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:adacd1c15f7ed1793453e56a675bd0a78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#adacd1c15f7ed1793453e56a675bd0a78">prologue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:adacd1c15f7ed1793453e56a675bd0a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for strings for JSON archives.  <a href="namespacecereal.html#adacd1c15f7ed1793453e56a675bd0a78">More...</a><br /></td></tr>
<tr class="separator:adacd1c15f7ed1793453e56a675bd0a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dde17944a1c24885e39ff673b402841"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a4dde17944a1c24885e39ff673b402841"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4dde17944a1c24885e39ff673b402841">prologue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a4dde17944a1c24885e39ff673b402841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for strings for JSON archives.  <a href="namespacecereal.html#a4dde17944a1c24885e39ff673b402841">More...</a><br /></td></tr>
<tr class="separator:a4dde17944a1c24885e39ff673b402841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06f0f66ced9dd9c85377ba61054df94"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:aa06f0f66ced9dd9c85377ba61054df94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa06f0f66ced9dd9c85377ba61054df94">epilogue</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:aa06f0f66ced9dd9c85377ba61054df94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for strings for JSON archives.  <a href="namespacecereal.html#aa06f0f66ced9dd9c85377ba61054df94">More...</a><br /></td></tr>
<tr class="separator:aa06f0f66ced9dd9c85377ba61054df94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733225f7be628b7c4dfca463d6a44253"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a733225f7be628b7c4dfca463d6a44253"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a733225f7be628b7c4dfca463d6a44253">epilogue</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a733225f7be628b7c4dfca463d6a44253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for strings for JSON archives.  <a href="namespacecereal.html#a733225f7be628b7c4dfca463d6a44253">More...</a><br /></td></tr>
<tr class="separator:a733225f7be628b7c4dfca463d6a44253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049f4acf75e647cce18b4b98c9037cfb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a049f4acf75e647cce18b4b98c9037cfb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a049f4acf75e647cce18b4b98c9037cfb">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;t)</td></tr>
<tr class="memdesc:a049f4acf75e647cce18b4b98c9037cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing NVP types to JSON.  <a href="namespacecereal.html#a049f4acf75e647cce18b4b98c9037cfb">More...</a><br /></td></tr>
<tr class="separator:a049f4acf75e647cce18b4b98c9037cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42319b92c41f6f15a86b69fcd87246d2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a42319b92c41f6f15a86b69fcd87246d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a42319b92c41f6f15a86b69fcd87246d2">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="separator:a42319b92c41f6f15a86b69fcd87246d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05ab834a18302c852181802b22d30ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ad05ab834a18302c852181802b22d30ec">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, std::nullptr_t <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;t)</td></tr>
<tr class="memdesc:ad05ab834a18302c852181802b22d30ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for nullptr to JSON.  <a href="namespacecereal.html#ad05ab834a18302c852181802b22d30ec">More...</a><br /></td></tr>
<tr class="separator:ad05ab834a18302c852181802b22d30ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7f1f974a532bbad87a7b4d8fe746e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aed7f1f974a532bbad87a7b4d8fe746e8">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, std::nullptr_t &amp;t)</td></tr>
<tr class="memdesc:aed7f1f974a532bbad87a7b4d8fe746e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading arithmetic from JSON.  <a href="namespacecereal.html#aed7f1f974a532bbad87a7b4d8fe746e8">More...</a><br /></td></tr>
<tr class="separator:aed7f1f974a532bbad87a7b4d8fe746e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a272e0c7b90d4591e8e0a13ebb17ca909">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;t)</td></tr>
<tr class="memdesc:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for arithmetic to JSON.  <a href="namespacecereal.html#a272e0c7b90d4591e8e0a13ebb17ca909">More...</a><br /></td></tr>
<tr class="separator:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f34376d3320a6fd7be58df311bd961"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:af0f34376d3320a6fd7be58df311bd961"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af0f34376d3320a6fd7be58df311bd961">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:af0f34376d3320a6fd7be58df311bd961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading arithmetic from JSON.  <a href="namespacecereal.html#af0f34376d3320a6fd7be58df311bd961">More...</a><br /></td></tr>
<tr class="separator:af0f34376d3320a6fd7be58df311bd961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cbcd5c53fd79f0f97b816820b013ff"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a94cbcd5c53fd79f0f97b816820b013ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a94cbcd5c53fd79f0f97b816820b013ff">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;str)</td></tr>
<tr class="memdesc:a94cbcd5c53fd79f0f97b816820b013ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">saving string to JSON  <a href="namespacecereal.html#a94cbcd5c53fd79f0f97b816820b013ff">More...</a><br /></td></tr>
<tr class="separator:a94cbcd5c53fd79f0f97b816820b013ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a8a9afcaeb51833d26e15a78d55e5ae30">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">loading string from JSON  <a href="namespacecereal.html#a8a9afcaeb51833d26e15a78d55e5ae30">More...</a><br /></td></tr>
<tr class="separator:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b30facce64dd6f270097f144f9ffde"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a66b30facce64dd6f270097f144f9ffde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a66b30facce64dd6f270097f144f9ffde">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a66b30facce64dd6f270097f144f9ffde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving SizeTags to JSON.  <a href="namespacecereal.html#a66b30facce64dd6f270097f144f9ffde">More...</a><br /></td></tr>
<tr class="separator:a66b30facce64dd6f270097f144f9ffde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7a02ebbdcca274a8c905878725057"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab8e7a02ebbdcca274a8c905878725057"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ab8e7a02ebbdcca274a8c905878725057">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; &amp;st)</td></tr>
<tr class="memdesc:ab8e7a02ebbdcca274a8c905878725057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading SizeTags from JSON.  <a href="namespacecereal.html#ab8e7a02ebbdcca274a8c905878725057">More...</a><br /></td></tr>
<tr class="separator:ab8e7a02ebbdcca274a8c905878725057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246b2dae9307a97ac4d8a44c3c42a0e1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a246b2dae9307a97ac4d8a44c3c42a0e1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a246b2dae9307a97ac4d8a44c3c42a0e1">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1PortableBinaryOutputArchive.html">PortableBinaryOutputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;t)</td></tr>
<tr class="memdesc:a246b2dae9307a97ac4d8a44c3c42a0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to portable binary.  <a href="namespacecereal.html#a246b2dae9307a97ac4d8a44c3c42a0e1">More...</a><br /></td></tr>
<tr class="separator:a246b2dae9307a97ac4d8a44c3c42a0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bb22e62be241f74289805e23f43c12"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a16bb22e62be241f74289805e23f43c12"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a16bb22e62be241f74289805e23f43c12">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1PortableBinaryInputArchive.html">PortableBinaryInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:a16bb22e62be241f74289805e23f43c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from portable binary.  <a href="namespacecereal.html#a16bb22e62be241f74289805e23f43c12">More...</a><br /></td></tr>
<tr class="separator:a16bb22e62be241f74289805e23f43c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4ba55a1d28e2db9a09ba767a4b1f16d7">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1PortableBinaryOutputArchive.html">PortableBinaryOutputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;bd)</td></tr>
<tr class="memdesc:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving binary data to portable binary.  <a href="namespacecereal.html#a4ba55a1d28e2db9a09ba767a4b1f16d7">More...</a><br /></td></tr>
<tr class="separator:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10780060393e472b72fb4a2158d641ec"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a10780060393e472b72fb4a2158d641ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a10780060393e472b72fb4a2158d641ec">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1PortableBinaryInputArchive.html">PortableBinaryInputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; &amp;bd)</td></tr>
<tr class="memdesc:a10780060393e472b72fb4a2158d641ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading binary data from portable binary.  <a href="namespacecereal.html#a10780060393e472b72fb4a2158d641ec">More...</a><br /></td></tr>
<tr class="separator:a10780060393e472b72fb4a2158d641ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2582cc8477f9482910fc5733e13f75f7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2582cc8477f9482910fc5733e13f75f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a2582cc8477f9482910fc5733e13f75f7">prologue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a2582cc8477f9482910fc5733e13f75f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for XML output archives.  <a href="namespacecereal.html#a2582cc8477f9482910fc5733e13f75f7">More...</a><br /></td></tr>
<tr class="separator:a2582cc8477f9482910fc5733e13f75f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06224101dfaf6979418326a7664e13e2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a06224101dfaf6979418326a7664e13e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a06224101dfaf6979418326a7664e13e2">prologue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a06224101dfaf6979418326a7664e13e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for XML input archives.  <a href="namespacecereal.html#a06224101dfaf6979418326a7664e13e2">More...</a><br /></td></tr>
<tr class="separator:a06224101dfaf6979418326a7664e13e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906ef65c3ab455598f768431bcd5f37d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a906ef65c3ab455598f768431bcd5f37d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a906ef65c3ab455598f768431bcd5f37d">epilogue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a906ef65c3ab455598f768431bcd5f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for XML output archives.  <a href="namespacecereal.html#a906ef65c3ab455598f768431bcd5f37d">More...</a><br /></td></tr>
<tr class="separator:a906ef65c3ab455598f768431bcd5f37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1af5fa5a466ad0cd89513aab823b80"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5d1af5fa5a466ad0cd89513aab823b80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a5d1af5fa5a466ad0cd89513aab823b80">epilogue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a5d1af5fa5a466ad0cd89513aab823b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for XML input archives.  <a href="namespacecereal.html#a5d1af5fa5a466ad0cd89513aab823b80">More...</a><br /></td></tr>
<tr class="separator:a5d1af5fa5a466ad0cd89513aab823b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6124c7acd34d3740cbedd39559da73c3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6124c7acd34d3740cbedd39559da73c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a6124c7acd34d3740cbedd39559da73c3">prologue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a6124c7acd34d3740cbedd39559da73c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for XML archives.  <a href="namespacecereal.html#a6124c7acd34d3740cbedd39559da73c3">More...</a><br /></td></tr>
<tr class="separator:a6124c7acd34d3740cbedd39559da73c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf285317856bf80daaa225e171d8d951"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adf285317856bf80daaa225e171d8d951"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#adf285317856bf80daaa225e171d8d951">prologue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:adf285317856bf80daaa225e171d8d951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for XML archives.  <a href="namespacecereal.html#adf285317856bf80daaa225e171d8d951">More...</a><br /></td></tr>
<tr class="separator:adf285317856bf80daaa225e171d8d951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1f17a3cae999a9be34889fd2c509a0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb1f17a3cae999a9be34889fd2c509a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#acb1f17a3cae999a9be34889fd2c509a0">epilogue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:acb1f17a3cae999a9be34889fd2c509a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for XML archives.  <a href="namespacecereal.html#acb1f17a3cae999a9be34889fd2c509a0">More...</a><br /></td></tr>
<tr class="separator:acb1f17a3cae999a9be34889fd2c509a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bbce1604367ea45c07dc677186ed64"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a70bbce1604367ea45c07dc677186ed64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a70bbce1604367ea45c07dc677186ed64">epilogue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a70bbce1604367ea45c07dc677186ed64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for XML archives.  <a href="namespacecereal.html#a70bbce1604367ea45c07dc677186ed64">More...</a><br /></td></tr>
<tr class="separator:a70bbce1604367ea45c07dc677186ed64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb541e9594201d78a04cb11ad806ba0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbb541e9594201d78a04cb11ad806ba0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#adbb541e9594201d78a04cb11ad806ba0">prologue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:adbb541e9594201d78a04cb11ad806ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for XML output archives.  <a href="namespacecereal.html#adbb541e9594201d78a04cb11ad806ba0">More...</a><br /></td></tr>
<tr class="separator:adbb541e9594201d78a04cb11ad806ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e6485f450649b931e07e0f6384a76"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa25e6485f450649b931e07e0f6384a76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa25e6485f450649b931e07e0f6384a76">prologue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="separator:aa25e6485f450649b931e07e0f6384a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3700f36066026da589faa60fed7ca53"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac3700f36066026da589faa60fed7ca53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac3700f36066026da589faa60fed7ca53">epilogue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:ac3700f36066026da589faa60fed7ca53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for XML output archives.  <a href="namespacecereal.html#ac3700f36066026da589faa60fed7ca53">More...</a><br /></td></tr>
<tr class="separator:ac3700f36066026da589faa60fed7ca53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada513bbfcf8c1996e6f7a439f129a208"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ada513bbfcf8c1996e6f7a439f129a208"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ada513bbfcf8c1996e6f7a439f129a208">epilogue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="separator:ada513bbfcf8c1996e6f7a439f129a208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af751c02a4443b571fee21416a4b899c1"><td class="memTemplParams" colspan="2">template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, XMLOutputArchive &gt;::value||traits::has_minimal_output_serialization&lt; T, XMLOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:af751c02a4443b571fee21416a4b899c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af751c02a4443b571fee21416a4b899c1">prologue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:af751c02a4443b571fee21416a4b899c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for XML output archives (except minimal types)  <a href="namespacecereal.html#af751c02a4443b571fee21416a4b899c1">More...</a><br /></td></tr>
<tr class="separator:af751c02a4443b571fee21416a4b899c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="memTemplParams" colspan="2">template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, XMLInputArchive &gt;::value||traits::has_minimal_input_serialization&lt; T, XMLInputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a7ea2b824c9d003b9e2b36473db1d22c0">prologue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for XML input archives (except minimal types)  <a href="namespacecereal.html#a7ea2b824c9d003b9e2b36473db1d22c0">More...</a><br /></td></tr>
<tr class="separator:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ca55f7d5556527de1584198ea3c414"><td class="memTemplParams" colspan="2">template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, XMLOutputArchive &gt;::value||traits::has_minimal_output_serialization&lt; T, XMLOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a16ca55f7d5556527de1584198ea3c414"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a16ca55f7d5556527de1584198ea3c414">epilogue</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a16ca55f7d5556527de1584198ea3c414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for XML output archives (except minimal types)  <a href="namespacecereal.html#a16ca55f7d5556527de1584198ea3c414">More...</a><br /></td></tr>
<tr class="separator:a16ca55f7d5556527de1584198ea3c414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06e3f89a66231db109db984a87e0cfd"><td class="memTemplParams" colspan="2">template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, XMLInputArchive &gt;::value||traits::has_minimal_input_serialization&lt; T, XMLInputArchive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:ae06e3f89a66231db109db984a87e0cfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ae06e3f89a66231db109db984a87e0cfd">epilogue</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:ae06e3f89a66231db109db984a87e0cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for XML output archives (except minimal types)  <a href="namespacecereal.html#ae06e3f89a66231db109db984a87e0cfd">More...</a><br /></td></tr>
<tr class="separator:ae06e3f89a66231db109db984a87e0cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a252f7731760e1186c3c552f640fc7b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a252f7731760e1186c3c552f640fc7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a9a252f7731760e1186c3c552f640fc7b">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;t)</td></tr>
<tr class="memdesc:a9a252f7731760e1186c3c552f640fc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving NVP types to XML.  <a href="namespacecereal.html#a9a252f7731760e1186c3c552f640fc7b">More...</a><br /></td></tr>
<tr class="separator:a9a252f7731760e1186c3c552f640fc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a08767af52642e109545f05a4694380"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0a08767af52642e109545f05a4694380"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0a08767af52642e109545f05a4694380">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a0a08767af52642e109545f05a4694380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading NVP types from XML.  <a href="namespacecereal.html#a0a08767af52642e109545f05a4694380">More...</a><br /></td></tr>
<tr class="separator:a0a08767af52642e109545f05a4694380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1703ea149fc65a4d7851fa85823287b2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1703ea149fc65a4d7851fa85823287b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a1703ea149fc65a4d7851fa85823287b2">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a1703ea149fc65a4d7851fa85823287b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving SizeTags to XML.  <a href="namespacecereal.html#a1703ea149fc65a4d7851fa85823287b2">More...</a><br /></td></tr>
<tr class="separator:a1703ea149fc65a4d7851fa85823287b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88090838a4dbf54f907dee8969c0d5cf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a88090838a4dbf54f907dee8969c0d5cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a88090838a4dbf54f907dee8969c0d5cf">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; &amp;st)</td></tr>
<tr class="memdesc:a88090838a4dbf54f907dee8969c0d5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading SizeTags from XML.  <a href="namespacecereal.html#a88090838a4dbf54f907dee8969c0d5cf">More...</a><br /></td></tr>
<tr class="separator:a88090838a4dbf54f907dee8969c0d5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6311a745c3a12848550eff8fba71f31"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:ac6311a745c3a12848550eff8fba71f31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac6311a745c3a12848550eff8fba71f31">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;t)</td></tr>
<tr class="memdesc:ac6311a745c3a12848550eff8fba71f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to xml.  <a href="namespacecereal.html#ac6311a745c3a12848550eff8fba71f31">More...</a><br /></td></tr>
<tr class="separator:ac6311a745c3a12848550eff8fba71f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea476a67114d4998f2113da658c25468"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:aea476a67114d4998f2113da658c25468"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aea476a67114d4998f2113da658c25468">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:aea476a67114d4998f2113da658c25468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from xml.  <a href="namespacecereal.html#aea476a67114d4998f2113da658c25468">More...</a><br /></td></tr>
<tr class="separator:aea476a67114d4998f2113da658c25468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63696aa0de3dc95bc27f97bf455d15e8"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a63696aa0de3dc95bc27f97bf455d15e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a63696aa0de3dc95bc27f97bf455d15e8">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;str)</td></tr>
<tr class="memdesc:a63696aa0de3dc95bc27f97bf455d15e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">saving string to xml  <a href="namespacecereal.html#a63696aa0de3dc95bc27f97bf455d15e8">More...</a><br /></td></tr>
<tr class="separator:a63696aa0de3dc95bc27f97bf455d15e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a3f5b214a91e6d61bcdae422e1cf27b37">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">loading string from xml  <a href="namespacecereal.html#a3f5b214a91e6d61bcdae422e1cf27b37">More...</a><br /></td></tr>
<tr class="separator:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8093b5f7cfd618fae6350ef7b2c09453"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a8093b5f7cfd618fae6350ef7b2c09453"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a8093b5f7cfd618fae6350ef7b2c09453">prologue</a> (Archive &amp;, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="separator:a8093b5f7cfd618fae6350ef7b2c09453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1153b7ce7ffbb86e2c81e076a252938e"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a1153b7ce7ffbb86e2c81e076a252938e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a1153b7ce7ffbb86e2c81e076a252938e">epilogue</a> (Archive &amp;, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="separator:a1153b7ce7ffbb86e2c81e076a252938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa227a94792fcb26dd3fd5c4588ed38d4"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class ValueType &gt; </td></tr>
<tr class="memitem:aa227a94792fcb26dd3fd5c4588ed38d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcereal_1_1MapItem.html">MapItem</a>&lt; KeyType, ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa227a94792fcb26dd3fd5c4588ed38d4">make_map_item</a> (KeyType &amp;&amp;key, ValueType &amp;&amp;value)</td></tr>
<tr class="memdesc:aa227a94792fcb26dd3fd5c4588ed38d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structcereal_1_1MapItem.html" title="A wrapper around a key and value for serializing data into maps.">MapItem</a> so that human readable archives will group keys and values together.  <a href="namespacecereal.html#aa227a94792fcb26dd3fd5c4588ed38d4">More...</a><br /></td></tr>
<tr class="separator:aa227a94792fcb26dd3fd5c4588ed38d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd86a3c7ebb03502832158513b91ee3"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:a7dd86a3c7ebb03502832158513b91ee3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a7dd86a3c7ebb03502832158513b91ee3">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;array)</td></tr>
<tr class="separator:a7dd86a3c7ebb03502832158513b91ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49547021764b554ce332679c9f9fec70"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:a49547021764b554ce332679c9f9fec70"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a49547021764b554ce332679c9f9fec70">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; &amp;array)</td></tr>
<tr class="separator:a49547021764b554ce332679c9f9fec70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008414a8d23778c73ddb47270d7d477f"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:a008414a8d23778c73ddb47270d7d477f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a008414a8d23778c73ddb47270d7d477f">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;array)</td></tr>
<tr class="memdesc:a008414a8d23778c73ddb47270d7d477f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::array all other types.  <a href="namespacecereal.html#a008414a8d23778c73ddb47270d7d477f">More...</a><br /></td></tr>
<tr class="separator:a008414a8d23778c73ddb47270d7d477f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e9db02cc3b58b053b47fb1456d8c92"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:aa2e9db02cc3b58b053b47fb1456d8c92"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa2e9db02cc3b58b053b47fb1456d8c92">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; &amp;array)</td></tr>
<tr class="memdesc:aa2e9db02cc3b58b053b47fb1456d8c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::array all other types.  <a href="namespacecereal.html#aa2e9db02cc3b58b053b47fb1456d8c92">More...</a><br /></td></tr>
<tr class="separator:aa2e9db02cc3b58b053b47fb1456d8c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bab555e921d35f6f713b7e1cab187a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a99bab555e921d35f6f713b7e1cab187a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a99bab555e921d35f6f713b7e1cab187a">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::atomic&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;<a class="el" href="pointer_8h.html#aeeddce917cf130d62c370b8f216026dd">a</a>)</td></tr>
<tr class="memdesc:a99bab555e921d35f6f713b7e1cab187a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::atomic.  <a href="namespacecereal.html#a99bab555e921d35f6f713b7e1cab187a">More...</a><br /></td></tr>
<tr class="separator:a99bab555e921d35f6f713b7e1cab187a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc0336db29043e0f692517c77f9e7de"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:abfc0336db29043e0f692517c77f9e7de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#abfc0336db29043e0f692517c77f9e7de">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::atomic&lt; T &gt; &amp;<a class="el" href="pointer_8h.html#aeeddce917cf130d62c370b8f216026dd">a</a>)</td></tr>
<tr class="memdesc:abfc0336db29043e0f692517c77f9e7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::atomic.  <a href="namespacecereal.html#abfc0336db29043e0f692517c77f9e7de">More...</a><br /></td></tr>
<tr class="separator:abfc0336db29043e0f692517c77f9e7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397c996c1b3e8bdcb3f43f11edf91126"><td class="memTemplParams" colspan="2">template&lt;class Archive , size_t N, traits::EnableIf&lt; traits::is_output_serializable&lt; BinaryData&lt; std::uint32_t &gt;, Archive &gt;::value &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a397c996c1b3e8bdcb3f43f11edf91126"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a397c996c1b3e8bdcb3f43f11edf91126">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::bitset&lt; <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;bits)</td></tr>
<tr class="memdesc:a397c996c1b3e8bdcb3f43f11edf91126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::bitset when <a class="el" href="structcereal_1_1BinaryData.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> optimization supported.  <a href="namespacecereal.html#a397c996c1b3e8bdcb3f43f11edf91126">More...</a><br /></td></tr>
<tr class="separator:a397c996c1b3e8bdcb3f43f11edf91126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="memTemplParams" colspan="2">template&lt;class Archive , size_t N&gt; </td></tr>
<tr class="memitem:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ad8cfa5e251b7a85343f0a92e93f50a60">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::bitset&lt; <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; &amp;bits)</td></tr>
<tr class="memdesc:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::bitset.  <a href="namespacecereal.html#ad8cfa5e251b7a85343f0a92e93f50a60">More...</a><br /></td></tr>
<tr class="separator:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef0d6cf11362910537f60cf2d977bff"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename ... VariantTypes&gt; </td></tr>
<tr class="memitem:aaef0d6cf11362910537f60cf2d977bff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aaef0d6cf11362910537f60cf2d977bff">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, boost::variant&lt; VariantTypes... &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;variant)</td></tr>
<tr class="memdesc:aaef0d6cf11362910537f60cf2d977bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for boost::variant.  <a href="namespacecereal.html#aaef0d6cf11362910537f60cf2d977bff">More...</a><br /></td></tr>
<tr class="separator:aaef0d6cf11362910537f60cf2d977bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890ad33a3d0ec4f9d7408e6e7e25e772"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename ... VariantTypes&gt; </td></tr>
<tr class="memitem:a890ad33a3d0ec4f9d7408e6e7e25e772"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a890ad33a3d0ec4f9d7408e6e7e25e772">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, boost::variant&lt; VariantTypes... &gt; &amp;variant)</td></tr>
<tr class="memdesc:a890ad33a3d0ec4f9d7408e6e7e25e772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for boost::variant.  <a href="namespacecereal.html#a890ad33a3d0ec4f9d7408e6e7e25e772">More...</a><br /></td></tr>
<tr class="separator:a890ad33a3d0ec4f9d7408e6e7e25e772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873e6efe3a391c89edbee86fb2a4b349"><td class="memTemplParams" colspan="2">template&lt;class Archive , class R , class P &gt; </td></tr>
<tr class="memitem:a873e6efe3a391c89edbee86fb2a4b349"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a873e6efe3a391c89edbee86fb2a4b349">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::duration&lt; R, P &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;dur)</td></tr>
<tr class="memdesc:a873e6efe3a391c89edbee86fb2a4b349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::chrono::duration.  <a href="namespacecereal.html#a873e6efe3a391c89edbee86fb2a4b349">More...</a><br /></td></tr>
<tr class="separator:a873e6efe3a391c89edbee86fb2a4b349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c5a2d538bb7606e5500f5e3a107e30"><td class="memTemplParams" colspan="2">template&lt;class Archive , class R , class P &gt; </td></tr>
<tr class="memitem:a09c5a2d538bb7606e5500f5e3a107e30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a09c5a2d538bb7606e5500f5e3a107e30">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::duration&lt; R, P &gt; &amp;dur)</td></tr>
<tr class="memdesc:a09c5a2d538bb7606e5500f5e3a107e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::chrono::duration.  <a href="namespacecereal.html#a09c5a2d538bb7606e5500f5e3a107e30">More...</a><br /></td></tr>
<tr class="separator:a09c5a2d538bb7606e5500f5e3a107e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977c1527242726fecf6cb1f492683ca6"><td class="memTemplParams" colspan="2">template&lt;class Archive , class C , class D &gt; </td></tr>
<tr class="memitem:a977c1527242726fecf6cb1f492683ca6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a977c1527242726fecf6cb1f492683ca6">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::time_point&lt; C, D &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;dur)</td></tr>
<tr class="memdesc:a977c1527242726fecf6cb1f492683ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::chrono::time_point.  <a href="namespacecereal.html#a977c1527242726fecf6cb1f492683ca6">More...</a><br /></td></tr>
<tr class="separator:a977c1527242726fecf6cb1f492683ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="memTemplParams" colspan="2">template&lt;class Archive , class C , class D &gt; </td></tr>
<tr class="memitem:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ab8b65d3b13a15b4f35c1b21553ab7649">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::time_point&lt; C, D &gt; &amp;dur)</td></tr>
<tr class="memdesc:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::chrono::time_point.  <a href="namespacecereal.html#ab8b65d3b13a15b4f35c1b21553ab7649">More...</a><br /></td></tr>
<tr class="separator:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073d35d55ad8dc81ce149fb799aab9f0"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a073d35d55ad8dc81ce149fb799aab9f0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::value, typename <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::base_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a073d35d55ad8dc81ce149fb799aab9f0">CEREAL_SAVE_MINIMAL_FUNCTION_NAME</a> (Archive <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;, T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;t)</td></tr>
<tr class="memdesc:a073d35d55ad8dc81ce149fb799aab9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for enum types.  <a href="namespacecereal.html#a073d35d55ad8dc81ce149fb799aab9f0">More...</a><br /></td></tr>
<tr class="separator:a073d35d55ad8dc81ce149fb799aab9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa110605d7a57863ad6cf9370332f446d"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa110605d7a57863ad6cf9370332f446d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa110605d7a57863ad6cf9370332f446d">CEREAL_LOAD_MINIMAL_FUNCTION_NAME</a> (Archive <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;, T &amp;&amp;t, typename <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::base_type <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;value)</td></tr>
<tr class="memdesc:aa110605d7a57863ad6cf9370332f446d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for enum types.  <a href="namespacecereal.html#aa110605d7a57863ad6cf9370332f446d">More...</a><br /></td></tr>
<tr class="separator:aa110605d7a57863ad6cf9370332f446d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676a85ac8cfcd512a743f930a10b6770"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a676a85ac8cfcd512a743f930a10b6770"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a676a85ac8cfcd512a743f930a10b6770">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;, T *&amp;)</td></tr>
<tr class="memdesc:a676a85ac8cfcd512a743f930a10b6770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for raw pointers.  <a href="namespacecereal.html#a676a85ac8cfcd512a743f930a10b6770">More...</a><br /></td></tr>
<tr class="separator:a676a85ac8cfcd512a743f930a10b6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22053a71b907666422b3a281be15bbc0"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a22053a71b907666422b3a281be15bbc0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_array&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a22053a71b907666422b3a281be15bbc0">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, T &amp;array)</td></tr>
<tr class="memdesc:a22053a71b907666422b3a281be15bbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for C style arrays.  <a href="namespacecereal.html#a22053a71b907666422b3a281be15bbc0">More...</a><br /></td></tr>
<tr class="separator:a22053a71b907666422b3a281be15bbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548257a795f8540c86333d0758fb99d5"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a548257a795f8540c86333d0758fb99d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a548257a795f8540c86333d0758fb99d5">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::complex&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;comp)</td></tr>
<tr class="memdesc:a548257a795f8540c86333d0758fb99d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::complex.  <a href="namespacecereal.html#a548257a795f8540c86333d0758fb99d5">More...</a><br /></td></tr>
<tr class="separator:a548257a795f8540c86333d0758fb99d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc7cefa0f45ae9d873598fdc607320e"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:afdc7cefa0f45ae9d873598fdc607320e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#afdc7cefa0f45ae9d873598fdc607320e">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::complex&lt; T &gt; &amp;bits)</td></tr>
<tr class="memdesc:afdc7cefa0f45ae9d873598fdc607320e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::complex.  <a href="namespacecereal.html#afdc7cefa0f45ae9d873598fdc607320e">More...</a><br /></td></tr>
<tr class="separator:afdc7cefa0f45ae9d873598fdc607320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="memTemplParams" colspan="2">template&lt;class Archive , template&lt; typename... &gt; class Map, typename... Args, typename  = typename Map&lt;Args...&gt;::mapped_type&gt; </td></tr>
<tr class="memitem:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0c5992e59041b20f902dd4fa0b2c62f1">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, Map&lt; Args... &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;map)</td></tr>
<tr class="memdesc:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std-like pair associative containers.  <a href="namespacecereal.html#a0c5992e59041b20f902dd4fa0b2c62f1">More...</a><br /></td></tr>
<tr class="separator:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679144f687ff95c7111ff96bccc573b3"><td class="memTemplParams" colspan="2">template&lt;class Archive , template&lt; typename... &gt; class Map, typename... Args, typename  = typename Map&lt;Args...&gt;::mapped_type&gt; </td></tr>
<tr class="memitem:a679144f687ff95c7111ff96bccc573b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a679144f687ff95c7111ff96bccc573b3">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, Map&lt; Args... &gt; &amp;map)</td></tr>
<tr class="memdesc:a679144f687ff95c7111ff96bccc573b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std-like pair associative containers.  <a href="namespacecereal.html#a679144f687ff95c7111ff96bccc573b3">More...</a><br /></td></tr>
<tr class="separator:a679144f687ff95c7111ff96bccc573b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a2e7e7370c46e4a819bd35fc1cdb856ad">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::deque&lt; T, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;deque)</td></tr>
<tr class="memdesc:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::deque.  <a href="namespacecereal.html#a2e7e7370c46e4a819bd35fc1cdb856ad">More...</a><br /></td></tr>
<tr class="separator:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284b8541ec2e00a17dada43f2d59d878"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a284b8541ec2e00a17dada43f2d59d878"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a284b8541ec2e00a17dada43f2d59d878">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::deque&lt; T, A &gt; &amp;deque)</td></tr>
<tr class="memdesc:a284b8541ec2e00a17dada43f2d59d878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::deque.  <a href="namespacecereal.html#a284b8541ec2e00a17dada43f2d59d878">More...</a><br /></td></tr>
<tr class="separator:a284b8541ec2e00a17dada43f2d59d878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a69af5df93ccfbbb3cc02575e3aeadbc6">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::forward_list&lt; T, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;forward_list)</td></tr>
<tr class="memdesc:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::forward_list all other types.  <a href="namespacecereal.html#a69af5df93ccfbbb3cc02575e3aeadbc6">More...</a><br /></td></tr>
<tr class="separator:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e9e22a3423e77493cee1d858372579"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a42e9e22a3423e77493cee1d858372579"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a42e9e22a3423e77493cee1d858372579">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::forward_list&lt; T, A &gt; &amp;forward_list)</td></tr>
<tr class="memdesc:a42e9e22a3423e77493cee1d858372579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::forward_list all other types from.  <a href="namespacecereal.html#a42e9e22a3423e77493cee1d858372579">More...</a><br /></td></tr>
<tr class="separator:a42e9e22a3423e77493cee1d858372579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a02f9cfc9a4055c8a49eb050b02cd3357">serialize</a> (Archive &amp;, std::less&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::less.  <a href="namespacecereal.html#a02f9cfc9a4055c8a49eb050b02cd3357">More...</a><br /></td></tr>
<tr class="separator:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ad5738ab4196d02509a5b69a58c7ca6ba">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::list&lt; T, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;list)</td></tr>
<tr class="memdesc:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::list.  <a href="namespacecereal.html#ad5738ab4196d02509a5b69a58c7ca6ba">More...</a><br /></td></tr>
<tr class="separator:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55808d42ce0c468d57c34bbc07827e59"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a55808d42ce0c468d57c34bbc07827e59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a55808d42ce0c468d57c34bbc07827e59">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::list&lt; T, A &gt; &amp;list)</td></tr>
<tr class="memdesc:a55808d42ce0c468d57c34bbc07827e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::list.  <a href="namespacecereal.html#a55808d42ce0c468d57c34bbc07827e59">More...</a><br /></td></tr>
<tr class="separator:a55808d42ce0c468d57c34bbc07827e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32e5d8031bde714f82138ab097ce135"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ae32e5d8031bde714f82138ab097ce135"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ae32e5d8031bde714f82138ab097ce135">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;ptr)</td></tr>
<tr class="memdesc:ae32e5d8031bde714f82138ab097ce135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for non polymorphic types.  <a href="namespacecereal.html#ae32e5d8031bde714f82138ab097ce135">More...</a><br /></td></tr>
<tr class="separator:ae32e5d8031bde714f82138ab097ce135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917df6d9415473be28a8a0791d293a35"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a917df6d9415473be28a8a0791d293a35"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a917df6d9415473be28a8a0791d293a35">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a917df6d9415473be28a8a0791d293a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when no user load and construct for non polymorphic types.  <a href="namespacecereal.html#a917df6d9415473be28a8a0791d293a35">More...</a><br /></td></tr>
<tr class="separator:a917df6d9415473be28a8a0791d293a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01e0b5b328b5a0db1fd64f75ad4cb9d"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa01e0b5b328b5a0db1fd64f75ad4cb9d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa01e0b5b328b5a0db1fd64f75ad4cb9d">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;ptr)</td></tr>
<tr class="memdesc:aa01e0b5b328b5a0db1fd64f75ad4cb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::weak_ptr for non polymorphic types.  <a href="namespacecereal.html#aa01e0b5b328b5a0db1fd64f75ad4cb9d">More...</a><br /></td></tr>
<tr class="separator:aa01e0b5b328b5a0db1fd64f75ad4cb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a621b3b41cd8058c9bde03b753aa86a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a4a621b3b41cd8058c9bde03b753aa86a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4a621b3b41cd8058c9bde03b753aa86a">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a4a621b3b41cd8058c9bde03b753aa86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::weak_ptr for non polymorphic types.  <a href="namespacecereal.html#a4a621b3b41cd8058c9bde03b753aa86a">More...</a><br /></td></tr>
<tr class="separator:a4a621b3b41cd8058c9bde03b753aa86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5365f19aa89df7a849d13592a41ea8"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:aaf5365f19aa89df7a849d13592a41ea8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aaf5365f19aa89df7a849d13592a41ea8">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;ptr)</td></tr>
<tr class="memdesc:aaf5365f19aa89df7a849d13592a41ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for non polymorphic types.  <a href="namespacecereal.html#aaf5365f19aa89df7a849d13592a41ea8">More...</a><br /></td></tr>
<tr class="separator:aaf5365f19aa89df7a849d13592a41ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1ca7735ec31c2b5e9d13be281321de"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:acb1ca7735ec31c2b5e9d13be281321de"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#acb1ca7735ec31c2b5e9d13be281321de">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:acb1ca7735ec31c2b5e9d13be281321de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct for non polymorphic types.  <a href="namespacecereal.html#acb1ca7735ec31c2b5e9d13be281321de">More...</a><br /></td></tr>
<tr class="separator:acb1ca7735ec31c2b5e9d13be281321de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac2dd1ac3ad73ad7203acdc21d7ea995a">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp; &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;wrapper)</td></tr>
<tr class="memdesc:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr (wrapper implementation)  <a href="namespacecereal.html#ac2dd1ac3ad73ad7203acdc21d7ea995a">More...</a><br /></td></tr>
<tr class="separator:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0396907ef9745cad405f1ff62215e28c"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a0396907ef9745cad405f1ff62215e28c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0396907ef9745cad405f1ff62215e28c">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:a0396907ef9745cad405f1ff62215e28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when user load and construct (wrapper implementation)  <a href="namespacecereal.html#a0396907ef9745cad405f1ff62215e28c">More...</a><br /></td></tr>
<tr class="separator:a0396907ef9745cad405f1ff62215e28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5809a4b7750b5a0c26c2818f0270f01"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa5809a4b7750b5a0c26c2818f0270f01"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa5809a4b7750b5a0c26c2818f0270f01">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:aa5809a4b7750b5a0c26c2818f0270f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when no user load and construct (wrapper implementation)  <a href="namespacecereal.html#aa5809a4b7750b5a0c26c2818f0270f01">More...</a><br /></td></tr>
<tr class="separator:aa5809a4b7750b5a0c26c2818f0270f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5576cf5fa2dc553adca652003d232d"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a7a5576cf5fa2dc553adca652003d232d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a7a5576cf5fa2dc553adca652003d232d">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp; &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;wrapper)</td></tr>
<tr class="memdesc:a7a5576cf5fa2dc553adca652003d232d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr (wrapper implementation)  <a href="namespacecereal.html#a7a5576cf5fa2dc553adca652003d232d">More...</a><br /></td></tr>
<tr class="separator:a7a5576cf5fa2dc553adca652003d232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a7f7ebd3faec04dd809f5b203a6adb"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:ae0a7f7ebd3faec04dd809f5b203a6adb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ae0a7f7ebd3faec04dd809f5b203a6adb">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:ae0a7f7ebd3faec04dd809f5b203a6adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct (wrapper implementation)  <a href="namespacecereal.html#ae0a7f7ebd3faec04dd809f5b203a6adb">More...</a><br /></td></tr>
<tr class="separator:ae0a7f7ebd3faec04dd809f5b203a6adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd284d9609d7b9c09d8779439e7f0c1"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a9fd284d9609d7b9c09d8779439e7f0c1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a9fd284d9609d7b9c09d8779439e7f0c1">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:a9fd284d9609d7b9c09d8779439e7f0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when no load_and_construct (wrapper implementation)  <a href="namespacecereal.html#a9fd284d9609d7b9c09d8779439e7f0c1">More...</a><br /></td></tr>
<tr class="separator:a9fd284d9609d7b9c09d8779439e7f0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede65f937d9a4d9ebaef35db8c6e7ae7"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename T &gt; </td></tr>
<tr class="memitem:aede65f937d9a4d9ebaef35db8c6e7ae7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aede65f937d9a4d9ebaef35db8c6e7ae7">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::optional&lt; T &gt; &amp;optional)</td></tr>
<tr class="memdesc:aede65f937d9a4d9ebaef35db8c6e7ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::optional.  <a href="namespacecereal.html#aede65f937d9a4d9ebaef35db8c6e7ae7">More...</a><br /></td></tr>
<tr class="separator:aede65f937d9a4d9ebaef35db8c6e7ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be4f81090e80f115a2ac4041a9f16ca"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename T &gt; </td></tr>
<tr class="memitem:a8be4f81090e80f115a2ac4041a9f16ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a8be4f81090e80f115a2ac4041a9f16ca">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::optional&lt; T &gt; &amp;optional)</td></tr>
<tr class="memdesc:a8be4f81090e80f115a2ac4041a9f16ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::optional.  <a href="namespacecereal.html#a8be4f81090e80f115a2ac4041a9f16ca">More...</a><br /></td></tr>
<tr class="separator:a8be4f81090e80f115a2ac4041a9f16ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759a15c02fad55311de9e5dd645a7319"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a759a15c02fad55311de9e5dd645a7319"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a759a15c02fad55311de9e5dd645a7319">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;ptr)</td></tr>
<tr class="memdesc:a759a15c02fad55311de9e5dd645a7319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, abstract.  <a href="namespacecereal.html#a759a15c02fad55311de9e5dd645a7319">More...</a><br /></td></tr>
<tr class="separator:a759a15c02fad55311de9e5dd645a7319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e1ce1157644fad605ade652112daf1"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa6e1ce1157644fad605ade652112daf1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;!std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa6e1ce1157644fad605ade652112daf1">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;ptr)</td></tr>
<tr class="memdesc:aa6e1ce1157644fad605ade652112daf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, not abstract.  <a href="namespacecereal.html#aa6e1ce1157644fad605ade652112daf1">More...</a><br /></td></tr>
<tr class="separator:aa6e1ce1157644fad605ade652112daf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162562abb32a0be716dbfb98f1a31a33"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a162562abb32a0be716dbfb98f1a31a33"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a162562abb32a0be716dbfb98f1a31a33">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a162562abb32a0be716dbfb98f1a31a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr for polymorphic types.  <a href="namespacecereal.html#a162562abb32a0be716dbfb98f1a31a33">More...</a><br /></td></tr>
<tr class="separator:a162562abb32a0be716dbfb98f1a31a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fd3494d3937e25e00c63e3822e8037"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:af0fd3494d3937e25e00c63e3822e8037"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af0fd3494d3937e25e00c63e3822e8037">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;ptr)</td></tr>
<tr class="memdesc:af0fd3494d3937e25e00c63e3822e8037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::weak_ptr for polymorphic types.  <a href="namespacecereal.html#af0fd3494d3937e25e00c63e3822e8037">More...</a><br /></td></tr>
<tr class="separator:af0fd3494d3937e25e00c63e3822e8037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cbd30aefc13f4a54094593603db13c"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa0cbd30aefc13f4a54094593603db13c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aa0cbd30aefc13f4a54094593603db13c">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:aa0cbd30aefc13f4a54094593603db13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::weak_ptr for polymorphic types.  <a href="namespacecereal.html#aa0cbd30aefc13f4a54094593603db13c">More...</a><br /></td></tr>
<tr class="separator:aa0cbd30aefc13f4a54094593603db13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7690f06f7ad55613cec7ae757b1750"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:aba7690f06f7ad55613cec7ae757b1750"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aba7690f06f7ad55613cec7ae757b1750">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;ptr)</td></tr>
<tr class="memdesc:aba7690f06f7ad55613cec7ae757b1750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types that are abstract.  <a href="namespacecereal.html#aba7690f06f7ad55613cec7ae757b1750">More...</a><br /></td></tr>
<tr class="separator:aba7690f06f7ad55613cec7ae757b1750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7296078465310c1af67d5674d7258c2"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:ab7296078465310c1af67d5674d7258c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value &amp;&amp;!std::is_abstract&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ab7296078465310c1af67d5674d7258c2">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;ptr)</td></tr>
<tr class="memdesc:ab7296078465310c1af67d5674d7258c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types, not abstract.  <a href="namespacecereal.html#ab7296078465310c1af67d5674d7258c2">More...</a><br /></td></tr>
<tr class="separator:ab7296078465310c1af67d5674d7258c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a8d1d69a4d25ed7715c105b14ed6f8957">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct for polymorphic types.  <a href="namespacecereal.html#a8d1d69a4d25ed7715c105b14ed6f8957">More...</a><br /></td></tr>
<tr class="separator:a8d1d69a4d25ed7715c105b14ed6f8957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a196f5ec0e6eb126730ee5fb7339fb8be">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::queue&lt; T, C &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;queue)</td></tr>
<tr class="memdesc:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::queue.  <a href="namespacecereal.html#a196f5ec0e6eb126730ee5fb7339fb8be">More...</a><br /></td></tr>
<tr class="separator:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663f35fc093d002d4e07c0e965178525"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:a663f35fc093d002d4e07c0e965178525"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a663f35fc093d002d4e07c0e965178525">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::queue&lt; T, C &gt; &amp;queue)</td></tr>
<tr class="memdesc:a663f35fc093d002d4e07c0e965178525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::queue.  <a href="namespacecereal.html#a663f35fc093d002d4e07c0e965178525">More...</a><br /></td></tr>
<tr class="separator:a663f35fc093d002d4e07c0e965178525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C , class Comp &gt; </td></tr>
<tr class="memitem:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ad1957ae53b8fc963c0ed3e831deae7ca">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::priority_queue&lt; T, C, Comp &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;priority_queue)</td></tr>
<tr class="memdesc:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::priority_queue.  <a href="namespacecereal.html#ad1957ae53b8fc963c0ed3e831deae7ca">More...</a><br /></td></tr>
<tr class="separator:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9335c1a68710bfa8f49ae3a217b32623"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C , class Comp &gt; </td></tr>
<tr class="memitem:a9335c1a68710bfa8f49ae3a217b32623"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a9335c1a68710bfa8f49ae3a217b32623">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::priority_queue&lt; T, C, Comp &gt; &amp;priority_queue)</td></tr>
<tr class="memdesc:a9335c1a68710bfa8f49ae3a217b32623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::priority_queue.  <a href="namespacecereal.html#a9335c1a68710bfa8f49ae3a217b32623">More...</a><br /></td></tr>
<tr class="separator:a9335c1a68710bfa8f49ae3a217b32623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a8cea063806602d60157cf1fb90878"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:a76a8cea063806602d60157cf1fb90878"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a76a8cea063806602d60157cf1fb90878">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::set&lt; K, C, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;set)</td></tr>
<tr class="memdesc:a76a8cea063806602d60157cf1fb90878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::set.  <a href="namespacecereal.html#a76a8cea063806602d60157cf1fb90878">More...</a><br /></td></tr>
<tr class="separator:a76a8cea063806602d60157cf1fb90878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a79a65f7506d96c59b25e5ad4bb6d6ad5">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::set&lt; K, C, A &gt; &amp;set)</td></tr>
<tr class="memdesc:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::set.  <a href="namespacecereal.html#a79a65f7506d96c59b25e5ad4bb6d6ad5">More...</a><br /></td></tr>
<tr class="separator:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aba7424502dce9a6a12bc8b0c34c8fa04">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::multiset&lt; K, C, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;multiset)</td></tr>
<tr class="memdesc:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::multiset.  <a href="namespacecereal.html#aba7424502dce9a6a12bc8b0c34c8fa04">More...</a><br /></td></tr>
<tr class="separator:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6668a1fc6b49fcf9c53633e3eb385826"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:a6668a1fc6b49fcf9c53633e3eb385826"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a6668a1fc6b49fcf9c53633e3eb385826">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::multiset&lt; K, C, A &gt; &amp;multiset)</td></tr>
<tr class="memdesc:a6668a1fc6b49fcf9c53633e3eb385826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::multiset.  <a href="namespacecereal.html#a6668a1fc6b49fcf9c53633e3eb385826">More...</a><br /></td></tr>
<tr class="separator:a6668a1fc6b49fcf9c53633e3eb385826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1f0d917ab00dd67f0b0e7d71737628"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:aca1f0d917ab00dd67f0b0e7d71737628"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aca1f0d917ab00dd67f0b0e7d71737628">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::stack&lt; T, C &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;stack)</td></tr>
<tr class="memdesc:aca1f0d917ab00dd67f0b0e7d71737628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::stack.  <a href="namespacecereal.html#aca1f0d917ab00dd67f0b0e7d71737628">More...</a><br /></td></tr>
<tr class="separator:aca1f0d917ab00dd67f0b0e7d71737628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f082383d87633cf69bdf0ab3d450ad"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:af7f082383d87633cf69bdf0ab3d450ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af7f082383d87633cf69bdf0ab3d450ad">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::stack&lt; T, C &gt; &amp;stack)</td></tr>
<tr class="memdesc:af7f082383d87633cf69bdf0ab3d450ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::stack.  <a href="namespacecereal.html#af7f082383d87633cf69bdf0ab3d450ad">More...</a><br /></td></tr>
<tr class="separator:af7f082383d87633cf69bdf0ab3d450ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c56736b1eca213cb9871171183c1675"><td class="memTemplParams" colspan="2">template&lt;class Archive , class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a0c56736b1eca213cb9871171183c1675"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; CharT &gt;, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0c56736b1eca213cb9871171183c1675">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;str)</td></tr>
<tr class="memdesc:a0c56736b1eca213cb9871171183c1675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for basic_string types, if binary data is supported.  <a href="namespacecereal.html#a0c56736b1eca213cb9871171183c1675">More...</a><br /></td></tr>
<tr class="separator:a0c56736b1eca213cb9871171183c1675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0888d39825d481241203372dbc106648"><td class="memTemplParams" colspan="2">template&lt;class Archive , class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a0888d39825d481241203372dbc106648"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; CharT &gt;, Archive &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0888d39825d481241203372dbc106648">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a0888d39825d481241203372dbc106648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for basic_string types, if binary data is supported.  <a href="namespacecereal.html#a0888d39825d481241203372dbc106648">More...</a><br /></td></tr>
<tr class="separator:a0888d39825d481241203372dbc106648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660edef0c6b018675e109062d459dc82"><td class="memTemplParams" colspan="2">template&lt;class Archive , class ... Types&gt; </td></tr>
<tr class="memitem:a660edef0c6b018675e109062d459dc82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a660edef0c6b018675e109062d459dc82">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, std::tuple&lt; Types... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a660edef0c6b018675e109062d459dc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing for std::tuple.  <a href="namespacecereal.html#a660edef0c6b018675e109062d459dc82">More...</a><br /></td></tr>
<tr class="separator:a660edef0c6b018675e109062d459dc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220a6067b52ed669c0c151d76567b561"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:a220a6067b52ed669c0c151d76567b561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a220a6067b52ed669c0c151d76567b561">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_set&lt; K, H, KE, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;unordered_set)</td></tr>
<tr class="memdesc:a220a6067b52ed669c0c151d76567b561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::unordered_set.  <a href="namespacecereal.html#a220a6067b52ed669c0c151d76567b561">More...</a><br /></td></tr>
<tr class="separator:a220a6067b52ed669c0c151d76567b561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b6234fc5a858bd294a833ccc9045ba"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:af0b6234fc5a858bd294a833ccc9045ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af0b6234fc5a858bd294a833ccc9045ba">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_set&lt; K, H, KE, A &gt; &amp;unordered_set)</td></tr>
<tr class="memdesc:af0b6234fc5a858bd294a833ccc9045ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::unordered_set.  <a href="namespacecereal.html#af0b6234fc5a858bd294a833ccc9045ba">More...</a><br /></td></tr>
<tr class="separator:af0b6234fc5a858bd294a833ccc9045ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4385e91ff798d9c5f8c336470011b889"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:a4385e91ff798d9c5f8c336470011b889"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4385e91ff798d9c5f8c336470011b889">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_multiset&lt; K, H, KE, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;unordered_multiset)</td></tr>
<tr class="memdesc:a4385e91ff798d9c5f8c336470011b889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::unordered_multiset.  <a href="namespacecereal.html#a4385e91ff798d9c5f8c336470011b889">More...</a><br /></td></tr>
<tr class="separator:a4385e91ff798d9c5f8c336470011b889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da956bad9ffcece46b8b3578a05567a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:a7da956bad9ffcece46b8b3578a05567a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a7da956bad9ffcece46b8b3578a05567a">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_multiset&lt; K, H, KE, A &gt; &amp;unordered_multiset)</td></tr>
<tr class="memdesc:a7da956bad9ffcece46b8b3578a05567a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::unordered_multiset.  <a href="namespacecereal.html#a7da956bad9ffcece46b8b3578a05567a">More...</a><br /></td></tr>
<tr class="separator:a7da956bad9ffcece46b8b3578a05567a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c80c9e74c022531318b7df731c1f73"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a83c80c9e74c022531318b7df731c1f73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a83c80c9e74c022531318b7df731c1f73">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, std::pair&lt; T1, T2 &gt; &amp;pair)</td></tr>
<tr class="memdesc:a83c80c9e74c022531318b7df731c1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing for std::pair.  <a href="namespacecereal.html#a83c80c9e74c022531318b7df731c1f73">More...</a><br /></td></tr>
<tr class="separator:a83c80c9e74c022531318b7df731c1f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebed7bbe6c0dacb0e02cf62306c6546f"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aebed7bbe6c0dacb0e02cf62306c6546f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#aebed7bbe6c0dacb0e02cf62306c6546f">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;valarray)</td></tr>
<tr class="memdesc:aebed7bbe6c0dacb0e02cf62306c6546f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::valarray arithmetic types, using binary serialization, if supported.  <a href="namespacecereal.html#aebed7bbe6c0dacb0e02cf62306c6546f">More...</a><br /></td></tr>
<tr class="separator:aebed7bbe6c0dacb0e02cf62306c6546f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffe563cc2d42f242fb634ee43e657dc"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a4ffe563cc2d42f242fb634ee43e657dc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a4ffe563cc2d42f242fb634ee43e657dc">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; &amp;valarray)</td></tr>
<tr class="memdesc:a4ffe563cc2d42f242fb634ee43e657dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::valarray arithmetic types, using binary serialization, if supported.  <a href="namespacecereal.html#a4ffe563cc2d42f242fb634ee43e657dc">More...</a><br /></td></tr>
<tr class="separator:a4ffe563cc2d42f242fb634ee43e657dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf57bfdff82b7b9c448ff92cc05e63c"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:abdf57bfdff82b7b9c448ff92cc05e63c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#abdf57bfdff82b7b9c448ff92cc05e63c">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;valarray)</td></tr>
<tr class="memdesc:abdf57bfdff82b7b9c448ff92cc05e63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::valarray all other types.  <a href="namespacecereal.html#abdf57bfdff82b7b9c448ff92cc05e63c">More...</a><br /></td></tr>
<tr class="separator:abdf57bfdff82b7b9c448ff92cc05e63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815c350d8ae5bbbf7ba42ff388796dd2"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a815c350d8ae5bbbf7ba42ff388796dd2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a815c350d8ae5bbbf7ba42ff388796dd2">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; &amp;valarray)</td></tr>
<tr class="memdesc:a815c350d8ae5bbbf7ba42ff388796dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::valarray all other types.  <a href="namespacecereal.html#a815c350d8ae5bbbf7ba42ff388796dd2">More...</a><br /></td></tr>
<tr class="separator:a815c350d8ae5bbbf7ba42ff388796dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216f04eb0fd673671c399e76270d7f5c"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename VariantType1 , typename... VariantTypes&gt; </td></tr>
<tr class="memitem:a216f04eb0fd673671c399e76270d7f5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a216f04eb0fd673671c399e76270d7f5c">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::variant&lt; VariantType1, VariantTypes... &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;variant)</td></tr>
<tr class="memdesc:a216f04eb0fd673671c399e76270d7f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::variant.  <a href="namespacecereal.html#a216f04eb0fd673671c399e76270d7f5c">More...</a><br /></td></tr>
<tr class="separator:a216f04eb0fd673671c399e76270d7f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d7a06a029441ecec4314f9fa64813e"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename... VariantTypes&gt; </td></tr>
<tr class="memitem:ac7d7a06a029441ecec4314f9fa64813e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac7d7a06a029441ecec4314f9fa64813e">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::variant&lt; VariantTypes... &gt; &amp;variant)</td></tr>
<tr class="memdesc:ac7d7a06a029441ecec4314f9fa64813e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::variant.  <a href="namespacecereal.html#ac7d7a06a029441ecec4314f9fa64813e">More...</a><br /></td></tr>
<tr class="separator:ac7d7a06a029441ecec4314f9fa64813e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e33aa2fc1bde7f59e9796f922cee3b9"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a0e33aa2fc1bde7f59e9796f922cee3b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a0e33aa2fc1bde7f59e9796f922cee3b9">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;, std::monostate <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;)</td></tr>
<tr class="memdesc:a0e33aa2fc1bde7f59e9796f922cee3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing a std::monostate.  <a href="namespacecereal.html#a0e33aa2fc1bde7f59e9796f922cee3b9">More...</a><br /></td></tr>
<tr class="separator:a0e33aa2fc1bde7f59e9796f922cee3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47624047ae8b341de607f9ff1306f472"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a47624047ae8b341de607f9ff1306f472"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a47624047ae8b341de607f9ff1306f472">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;vector)</td></tr>
<tr class="memdesc:a47624047ae8b341de607f9ff1306f472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported.  <a href="namespacecereal.html#a47624047ae8b341de607f9ff1306f472">More...</a><br /></td></tr>
<tr class="separator:a47624047ae8b341de607f9ff1306f472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ef05e6fe2f50deb4a33c04980b7439"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:ac3ef05e6fe2f50deb4a33c04980b7439"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value &amp;&amp;std::is_arithmetic&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#ac3ef05e6fe2f50deb4a33c04980b7439">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:ac3ef05e6fe2f50deb4a33c04980b7439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported.  <a href="namespacecereal.html#ac3ef05e6fe2f50deb4a33c04980b7439">More...</a><br /></td></tr>
<tr class="separator:ac3ef05e6fe2f50deb4a33c04980b7439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40e27831d6e777f7d69c3b4e2226d6c"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:af40e27831d6e777f7d69c3b4e2226d6c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value) &amp;&amp;!std::is_same&lt; T, bool &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af40e27831d6e777f7d69c3b4e2226d6c">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;vector)</td></tr>
<tr class="memdesc:af40e27831d6e777f7d69c3b4e2226d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for non-arithmetic vector types.  <a href="namespacecereal.html#af40e27831d6e777f7d69c3b4e2226d6c">More...</a><br /></td></tr>
<tr class="separator:af40e27831d6e777f7d69c3b4e2226d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af259757ceb4da16abe348c79637a2574"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:af259757ceb4da16abe348c79637a2574"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt;, Archive &gt;::value||!std::is_arithmetic&lt; T &gt;::value) &amp;&amp;!std::is_same&lt; T, bool &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#af259757ceb4da16abe348c79637a2574">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:af259757ceb4da16abe348c79637a2574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for non-arithmetic vector types.  <a href="namespacecereal.html#af259757ceb4da16abe348c79637a2574">More...</a><br /></td></tr>
<tr class="separator:af259757ceb4da16abe348c79637a2574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="memTemplParams" colspan="2">template&lt;class Archive , class A &gt; </td></tr>
<tr class="memitem:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a76b613c5fc7ae5ec8f8216a6337955a7">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; bool, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;vector)</td></tr>
<tr class="memdesc:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for bool vector types.  <a href="namespacecereal.html#a76b613c5fc7ae5ec8f8216a6337955a7">More...</a><br /></td></tr>
<tr class="separator:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="memTemplParams" colspan="2">template&lt;class Archive , class A &gt; </td></tr>
<tr class="memitem:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal.html#a09c7d1d922569ba782c8ec6d8f79b3e8">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; bool, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for bool vector types.  <a href="namespacecereal.html#a09c7d1d922569ba782c8ec6d8f79b3e8">More...</a><br /></td></tr>
<tr class="separator:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>in certain simple scenarios. They should probably not be used if maximizing performance is the main objective. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aba657f7ef148daa498dc4fa9e579b01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba657f7ef148daa498dc4fa9e579b01e">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecereal.html#aba657f7ef148daa498dc4fa9e579b01e">cereal::size_type</a> = typedef <a class="el" href="macros_8hpp.html#a2ad098b163a5f4829eb00fd7fb0b408d">CEREAL_SIZE_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size type used by cereal. </p>
<p>To ensure compatability between 32, 64, etc bit machines, we need to use a fixed size type instead of size_t, which may vary from machine to machine.</p>
<p>The default value for CEREAL_SIZE_TYPE is specified in <a class="el" href="macros_8hpp.html" title="Preprocessor macros that can customise the cereal library.">cereal/macros.hpp</a> </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a95185aa9f39e4ac382bb6631beb68a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95185aa9f39e4ac382bb6631beb68a67">&#9670;&nbsp;</a></span>Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecereal.html#a95185aa9f39e4ac382bb6631beb68a67">cereal::Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special flags for archives. </p>
<p>AllowEmptyClassElision This allows for empty classes to be serialized even if they do not provide a serialization function. Classes with no data members are considered to be empty. Be warned that if this is enabled and you attempt to serialize an empty class with improperly formed serialize or load/save functions, no static error will occur - the error will propagate silently and your intended serialization functions may not be called. You can manually ensure that your classes that have custom serialization are correct by using the traits is_output_serializable and is_input_serializable in <a class="el" href="traits_8hpp.html" title="Internal type trait support.">cereal/details/traits.hpp</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95185aa9f39e4ac382bb6631beb68a67ae264e38ef1170510fbdfa5f1e4d5c532"></a>AllowEmptyClassElision&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac28bb730353e53b3066cc679e63bb108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28bb730353e53b3066cc679e63bb108">&#9670;&nbsp;</a></span>specialization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , specialization S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum specialization</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A specifier used in conjunction with <a class="el" href="structcereal_1_1specialize.html" title="A class used to disambiguate cases where cereal cannot detect a unique way of serializing a class.">cereal::specialize</a> to disambiguate serialization in special cases </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a890ad33a3d0ec4f9d7408e6e7e25e772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890ad33a3d0ec4f9d7408e6e7e25e772">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[1/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename ... VariantTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::variant&lt; VariantTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>variant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for boost::variant. </p>

</div>
</div>
<a id="a679144f687ff95c7111ff96bccc573b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679144f687ff95c7111ff96bccc573b3">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[2/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , template&lt; typename... &gt; class Map, typename... Args, typename  = typename Map&lt;Args...&gt;::mapped_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; Args... &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std-like pair associative containers. </p>

</div>
</div>
<a id="a0396907ef9745cad405f1ff62215e28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0396907ef9745cad405f1ff62215e28c">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[3/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt;T, Archive&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;&#160;</td>
          <td class="paramname"><em>wrapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::shared_ptr, case when user load and construct (wrapper implementation) </p>

</div>
</div>
<a id="aa5809a4b7750b5a0c26c2818f0270f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5809a4b7750b5a0c26c2818f0270f01">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[4/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt;T, Archive&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;&#160;</td>
          <td class="paramname"><em>wrapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::shared_ptr, case when no user load and construct (wrapper implementation) </p>

</div>
</div>
<a id="ae0a7f7ebd3faec04dd809f5b203a6adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a7f7ebd3faec04dd809f5b203a6adb">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[5/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt;T, Archive&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;&#160;</td>
          <td class="paramname"><em>wrapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::unique_ptr, case when user provides load_and_construct (wrapper implementation) </p>

</div>
</div>
<a id="a9fd284d9609d7b9c09d8779439e7f0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd284d9609d7b9c09d8779439e7f0c1">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[6/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt;T, Archive&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;&#160;</td>
          <td class="paramname"><em>wrapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::unique_ptr, case when no load_and_construct (wrapper implementation) </p>

</div>
</div>
<a id="a49547021764b554ce332679c9f9fec70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49547021764b554ce332679c9f9fec70">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[7/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value &amp;&amp; std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loading for std::array primitive types using binary serialization, if supported </p>

</div>
</div>
<a id="aa2e9db02cc3b58b053b47fb1456d8c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e9db02cc3b58b053b47fb1456d8c92">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[8/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value || !std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::array all other types. </p>

</div>
</div>
<a id="abfc0336db29043e0f692517c77f9e7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc0336db29043e0f692517c77f9e7de">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[9/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (load) for std::atomic. </p>

</div>
</div>
<a id="a0888d39825d481241203372dbc106648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0888d39825d481241203372dbc106648">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[10/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;CharT&gt;, Archive&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for basic_string types, if binary data is supported. </p>

</div>
</div>
<a id="ad8cfa5e251b7a85343f0a92e93f50a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cfa5e251b7a85343f0a92e93f50a60">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[11/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::bitset&lt; <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (load) for std::bitset. </p>

</div>
</div>
<a id="a09c5a2d538bb7606e5500f5e3a107e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c5a2d538bb7606e5500f5e3a107e30">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[12/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class R , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; R, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>dur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::chrono::duration. </p>

</div>
</div>
<a id="ab8b65d3b13a15b4f35c1b21553ab7649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b65d3b13a15b4f35c1b21553ab7649">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[13/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class C , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; C, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>dur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::chrono::time_point. </p>

</div>
</div>
<a id="afdc7cefa0f45ae9d873598fdc607320e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc7cefa0f45ae9d873598fdc607320e">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[14/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (load) for std::complex. </p>

</div>
</div>
<a id="a284b8541ec2e00a17dada43f2d59d878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284b8541ec2e00a17dada43f2d59d878">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[15/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>deque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::deque. </p>

</div>
</div>
<a id="a42e9e22a3423e77493cee1d858372579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e9e22a3423e77493cee1d858372579">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[16/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>forward_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loading for std::forward_list all other types from. </p>

</div>
</div>
<a id="a55808d42ce0c468d57c34bbc07827e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55808d42ce0c468d57c34bbc07827e59">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[17/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::list. </p>

</div>
</div>
<a id="a6668a1fc6b49fcf9c53633e3eb385826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6668a1fc6b49fcf9c53633e3eb385826">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[18/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class C , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::multiset&lt; K, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::multiset. </p>

</div>
</div>
<a id="a8be4f81090e80f115a2ac4041a9f16ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be4f81090e80f115a2ac4041a9f16ca">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[19/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>optional</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::optional. </p>

</div>
</div>
<a id="a9335c1a68710bfa8f49ae3a217b32623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9335c1a68710bfa8f49ae3a217b32623">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[20/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C , class Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::priority_queue&lt; T, C, Comp &gt; &amp;&#160;</td>
          <td class="paramname"><em>priority_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::priority_queue. </p>

</div>
</div>
<a id="a663f35fc093d002d4e07c0e965178525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663f35fc093d002d4e07c0e965178525">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[21/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; T, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::queue. </p>

</div>
</div>
<a id="a79a65f7506d96c59b25e5ad4bb6d6ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a65f7506d96c59b25e5ad4bb6d6ad5">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[22/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class C , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; K, C, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::set. </p>

</div>
</div>
<a id="a917df6d9415473be28a8a0791d293a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917df6d9415473be28a8a0791d293a35">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[23/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::shared_ptr, case when no user load and construct for non polymorphic types. </p>

</div>
</div>
<a id="a162562abb32a0be716dbfb98f1a31a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162562abb32a0be716dbfb98f1a31a33">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[24/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::shared_ptr for polymorphic types. </p>

</div>
</div>
<a id="af7f082383d87633cf69bdf0ab3d450ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f082383d87633cf69bdf0ab3d450ad">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[25/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; T, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>stack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::stack. </p>

</div>
</div>
<a id="acb1ca7735ec31c2b5e9d13be281321de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1ca7735ec31c2b5e9d13be281321de">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[26/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::unique_ptr, case when user provides load_and_construct for non polymorphic types. </p>

</div>
</div>
<a id="a8d1d69a4d25ed7715c105b14ed6f8957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1d69a4d25ed7715c105b14ed6f8957">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[27/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::unique_ptr, case when user provides load_and_construct for polymorphic types. </p>

</div>
</div>
<a id="a7da956bad9ffcece46b8b3578a05567a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da956bad9ffcece46b8b3578a05567a">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[28/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class H , class KE , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_multiset&lt; K, H, KE, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>unordered_multiset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::unordered_multiset. </p>

</div>
</div>
<a id="af0b6234fc5a858bd294a833ccc9045ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b6234fc5a858bd294a833ccc9045ba">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[29/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class H , class KE , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; K, H, KE, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>unordered_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::unordered_set. </p>

</div>
</div>
<a id="a4ffe563cc2d42f242fb634ee43e657dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffe563cc2d42f242fb634ee43e657dc">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[30/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value &amp;&amp; std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valarray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::valarray arithmetic types, using binary serialization, if supported. </p>

</div>
</div>
<a id="a815c350d8ae5bbbf7ba42ff388796dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815c350d8ae5bbbf7ba42ff388796dd2">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[31/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value || !std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valarray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::valarray all other types. </p>

</div>
</div>
<a id="ac7d7a06a029441ecec4314f9fa64813e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d7a06a029441ecec4314f9fa64813e">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[32/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename... VariantTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::variant&lt; VariantTypes... &gt; &amp;&#160;</td>
          <td class="paramname"><em>variant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::variant. </p>

</div>
</div>
<a id="a09c7d1d922569ba782c8ec6d8f79b3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c7d1d922569ba782c8ec6d8f79b3e8">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[33/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for bool vector types. </p>

</div>
</div>
<a id="ac3ef05e6fe2f50deb4a33c04980b7439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ef05e6fe2f50deb4a33c04980b7439">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[34/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value &amp;&amp; std::is_arithmetic&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported. </p>

</div>
</div>
<a id="af259757ceb4da16abe348c79637a2574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af259757ceb4da16abe348c79637a2574">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[35/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value || !std::is_arithmetic&lt;T&gt;::value) &amp;&amp; !std::is_same&lt;T, bool&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for non-arithmetic vector types. </p>

</div>
</div>
<a id="a4a621b3b41cd8058c9bde03b753aa86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a621b3b41cd8058c9bde03b753aa86a">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[36/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::weak_ptr for non polymorphic types. </p>

</div>
</div>
<a id="aa0cbd30aefc13f4a54094593603db13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cbd30aefc13f4a54094593603db13c">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[37/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::weak_ptr for polymorphic types. </p>

</div>
</div>
<a id="af8577c2834d64922e9460cad77f9a3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8577c2834d64922e9460cad77f9a3ac">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[38/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1BinaryInputArchive.html">BinaryInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading binary data. </p>

</div>
</div>
<a id="a4d9235c50bdb3961865274a086dda972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9235c50bdb3961865274a086dda972">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[39/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1BinaryInputArchive.html">BinaryInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for POD types from binary. </p>

</div>
</div>
<a id="a42319b92c41f6f15a86b69fcd87246d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42319b92c41f6f15a86b69fcd87246d2">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[40/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8e7a02ebbdcca274a8c905878725057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e7a02ebbdcca274a8c905878725057">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[41/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading SizeTags from JSON. </p>

</div>
</div>
<a id="a8a9afcaeb51833d26e15a78d55e5ae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9afcaeb51833d26e15a78d55e5ae30">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[42/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>loading string from JSON </p>

</div>
</div>
<a id="aed7f1f974a532bbad87a7b4d8fe746e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7f1f974a532bbad87a7b4d8fe746e8">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[43/50]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading arithmetic from JSON. </p>

</div>
</div>
<a id="af0f34376d3320a6fd7be58df311bd961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f34376d3320a6fd7be58df311bd961">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[44/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading arithmetic from JSON. </p>

</div>
</div>
<a id="a10780060393e472b72fb4a2158d641ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10780060393e472b72fb4a2158d641ec">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[45/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1PortableBinaryInputArchive.html">PortableBinaryInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading binary data from portable binary. </p>

</div>
</div>
<a id="a16bb22e62be241f74289805e23f43c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bb22e62be241f74289805e23f43c12">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[46/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1PortableBinaryInputArchive.html">PortableBinaryInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for POD types from portable binary. </p>

</div>
</div>
<a id="a0a08767af52642e109545f05a4694380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a08767af52642e109545f05a4694380">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[47/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading NVP types from XML. </p>

</div>
</div>
<a id="a88090838a4dbf54f907dee8969c0d5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88090838a4dbf54f907dee8969c0d5cf">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[48/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading SizeTags from XML. </p>

</div>
</div>
<a id="a3f5b214a91e6d61bcdae422e1cf27b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5b214a91e6d61bcdae422e1cf27b37">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[49/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>loading string from xml </p>

</div>
</div>
<a id="aea476a67114d4998f2113da658c25468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea476a67114d4998f2113da658c25468">&#9670;&nbsp;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[50/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for POD types from xml. </p>

</div>
</div>
<a id="aa110605d7a57863ad6cf9370332f446d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa110605d7a57863ad6cf9370332f446d">&#9670;&nbsp;</a></span>CEREAL_LOAD_MINIMAL_FUNCTION_NAME()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt;T&gt;::value, void&gt;::type cereal::CEREAL_LOAD_MINIMAL_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::base_type <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for enum types. </p>

</div>
</div>
<a id="aaef0d6cf11362910537f60cf2d977bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef0d6cf11362910537f60cf2d977bff">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[1/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename ... VariantTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::variant&lt; VariantTypes... &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>variant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for boost::variant. </p>

</div>
</div>
<a id="aede65f937d9a4d9ebaef35db8c6e7ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede65f937d9a4d9ebaef35db8c6e7ae7">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[2/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>optional</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::optional. </p>

</div>
</div>
<a id="a0c5992e59041b20f902dd4fa0b2c62f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5992e59041b20f902dd4fa0b2c62f1">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[3/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , template&lt; typename... &gt; class Map, typename... Args, typename  = typename Map&lt;Args...&gt;::mapped_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; Args... &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std-like pair associative containers. </p>

</div>
</div>
<a id="ac2dd1ac3ad73ad7203acdc21d7ea995a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dd1ac3ad73ad7203acdc21d7ea995a">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[4/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp; &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::shared_ptr (wrapper implementation) </p>

</div>
</div>
<a id="a7a5576cf5fa2dc553adca652003d232d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5576cf5fa2dc553adca652003d232d">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[5/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1PtrWrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp; &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::unique_ptr (wrapper implementation) </p>

</div>
</div>
<a id="a7dd86a3c7ebb03502832158513b91ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd86a3c7ebb03502832158513b91ee3">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[6/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value &amp;&amp; std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saving for std::array primitive types using binary serialization, if supported </p>

</div>
</div>
<a id="a008414a8d23778c73ddb47270d7d477f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008414a8d23778c73ddb47270d7d477f">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[7/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value || !std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::array all other types. </p>

</div>
</div>
<a id="a99bab555e921d35f6f713b7e1cab187a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bab555e921d35f6f713b7e1cab187a">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[8/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::atomic&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (save) for std::atomic. </p>

</div>
</div>
<a id="a0c56736b1eca213cb9871171183c1675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c56736b1eca213cb9871171183c1675">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[9/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;CharT&gt;, Archive&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for basic_string types, if binary data is supported. </p>

</div>
</div>
<a id="a397c996c1b3e8bdcb3f43f11edf91126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397c996c1b3e8bdcb3f43f11edf91126">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[10/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , size_t N, traits::EnableIf&lt; traits::is_output_serializable&lt; BinaryData&lt; std::uint32_t &gt;, Archive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::bitset&lt; <a class="el" href="group__Texturing.html#ga7722c8ecbb62d99aee7ce68b1752f337">N</a> &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (save) for std::bitset when <a class="el" href="structcereal_1_1BinaryData.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> optimization supported. </p>
<p>Serializing (save) for std::bitset when <a class="el" href="structcereal_1_1BinaryData.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> is not supported. </p>

</div>
</div>
<a id="a873e6efe3a391c89edbee86fb2a4b349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873e6efe3a391c89edbee86fb2a4b349">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[11/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class R , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; R, P &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>dur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::chrono::duration. </p>

</div>
</div>
<a id="a977c1527242726fecf6cb1f492683ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977c1527242726fecf6cb1f492683ca6">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[12/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class C , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; C, D &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>dur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::chrono::time_point. </p>

</div>
</div>
<a id="a548257a795f8540c86333d0758fb99d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548257a795f8540c86333d0758fb99d5">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[13/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (save) for std::complex. </p>

</div>
</div>
<a id="a2e7e7370c46e4a819bd35fc1cdb856ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7e7370c46e4a819bd35fc1cdb856ad">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[14/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; T, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>deque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::deque. </p>

</div>
</div>
<a id="a69af5df93ccfbbb3cc02575e3aeadbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69af5df93ccfbbb3cc02575e3aeadbc6">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[15/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; T, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>forward_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::forward_list all other types. </p>

</div>
</div>
<a id="ad5738ab4196d02509a5b69a58c7ca6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5738ab4196d02509a5b69a58c7ca6ba">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[16/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; T, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::list. </p>

</div>
</div>
<a id="aba7424502dce9a6a12bc8b0c34c8fa04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7424502dce9a6a12bc8b0c34c8fa04">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[17/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class C , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::multiset&lt; K, C, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>multiset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::multiset. </p>

</div>
</div>
<a id="ad1957ae53b8fc963c0ed3e831deae7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1957ae53b8fc963c0ed3e831deae7ca">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[18/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C , class Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::priority_queue&lt; T, C, Comp &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>priority_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::priority_queue. </p>

</div>
</div>
<a id="a196f5ec0e6eb126730ee5fb7339fb8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196f5ec0e6eb126730ee5fb7339fb8be">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[19/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; T, C &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::queue. </p>

</div>
</div>
<a id="a76a8cea063806602d60157cf1fb90878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a8cea063806602d60157cf1fb90878">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[20/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class C , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; K, C, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::set. </p>

</div>
</div>
<a id="ae32e5d8031bde714f82138ab097ce135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32e5d8031bde714f82138ab097ce135">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[21/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::shared_ptr for non polymorphic types. </p>

</div>
</div>
<a id="a759a15c02fad55311de9e5dd645a7319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759a15c02fad55311de9e5dd645a7319">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[22/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value &amp;&amp; std::is_abstract&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::shared_ptr for polymorphic types, abstract. </p>

</div>
</div>
<a id="aa6e1ce1157644fad605ade652112daf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e1ce1157644fad605ade652112daf1">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[23/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value &amp;&amp; !std::is_abstract&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::shared_ptr for polymorphic types, not abstract. </p>

</div>
</div>
<a id="aca1f0d917ab00dd67f0b0e7d71737628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1f0d917ab00dd67f0b0e7d71737628">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[24/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; T, C &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>stack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::stack. </p>

</div>
</div>
<a id="aaf5365f19aa89df7a849d13592a41ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5365f19aa89df7a849d13592a41ea8">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[25/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::unique_ptr for non polymorphic types. </p>

</div>
</div>
<a id="aba7690f06f7ad55613cec7ae757b1750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7690f06f7ad55613cec7ae757b1750">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[26/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value &amp;&amp; std::is_abstract&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::unique_ptr for polymorphic types that are abstract. </p>

</div>
</div>
<a id="ab7296078465310c1af67d5674d7258c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7296078465310c1af67d5674d7258c2">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[27/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value &amp;&amp; !std::is_abstract&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::unique_ptr for polymorphic types, not abstract. </p>

</div>
</div>
<a id="a4385e91ff798d9c5f8c336470011b889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4385e91ff798d9c5f8c336470011b889">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[28/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class H , class KE , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_multiset&lt; K, H, KE, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>unordered_multiset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::unordered_multiset. </p>

</div>
</div>
<a id="a220a6067b52ed669c0c151d76567b561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220a6067b52ed669c0c151d76567b561">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[29/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class H , class KE , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; K, H, KE, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>unordered_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::unordered_set. </p>

</div>
</div>
<a id="aebed7bbe6c0dacb0e02cf62306c6546f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebed7bbe6c0dacb0e02cf62306c6546f">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[30/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value &amp;&amp; std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>valarray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::valarray arithmetic types, using binary serialization, if supported. </p>

</div>
</div>
<a id="abdf57bfdff82b7b9c448ff92cc05e63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf57bfdff82b7b9c448ff92cc05e63c">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[31/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value || !std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>valarray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::valarray all other types. </p>

</div>
</div>
<a id="a216f04eb0fd673671c399e76270d7f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216f04eb0fd673671c399e76270d7f5c">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[32/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename VariantType1 , typename... VariantTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::variant&lt; VariantType1, VariantTypes... &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>variant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::variant. </p>

</div>
</div>
<a id="a76b613c5fc7ae5ec8f8216a6337955a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b613c5fc7ae5ec8f8216a6337955a7">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[33/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for bool vector types. </p>

</div>
</div>
<a id="a47624047ae8b341de607f9ff1306f472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47624047ae8b341de607f9ff1306f472">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[34/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value &amp;&amp; std::is_arithmetic&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported. </p>

</div>
</div>
<a id="af40e27831d6e777f7d69c3b4e2226d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40e27831d6e777f7d69c3b4e2226d6c">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[35/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt;<a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt;T&gt;, Archive&gt;::value || !std::is_arithmetic&lt;T&gt;::value) &amp;&amp; !std::is_same&lt;T, bool&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, A &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for non-arithmetic vector types. </p>

</div>
</div>
<a id="aa01e0b5b328b5a0db1fd64f75ad4cb9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01e0b5b328b5a0db1fd64f75ad4cb9d">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[36/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::weak_ptr for non polymorphic types. </p>

</div>
</div>
<a id="af0fd3494d3937e25e00c63e3822e8037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fd3494d3937e25e00c63e3822e8037">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[37/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_polymorphic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::weak_ptr for polymorphic types. </p>

</div>
</div>
<a id="a189662781a0f3b710901f892d87792d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189662781a0f3b710901f892d87792d5">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[38/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1BinaryOutputArchive.html">BinaryOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>bd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving binary data. </p>

</div>
</div>
<a id="a8aeb7b414512d91291d759aaa284a8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aeb7b414512d91291d759aaa284a8c2">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[39/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1BinaryOutputArchive.html">BinaryOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for POD types to binary. </p>

</div>
</div>
<a id="a66b30facce64dd6f270097f144f9ffde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b30facce64dd6f270097f144f9ffde">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[40/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving SizeTags to JSON. </p>

</div>
</div>
<a id="a049f4acf75e647cce18b4b98c9037cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049f4acf75e647cce18b4b98c9037cfb">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[41/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing NVP types to JSON. </p>

</div>
</div>
<a id="a94cbcd5c53fd79f0f97b816820b013ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cbcd5c53fd79f0f97b816820b013ff">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[42/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>saving string to JSON </p>

</div>
</div>
<a id="ad05ab834a18302c852181802b22d30ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05ab834a18302c852181802b22d30ec">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[43/50]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for nullptr to JSON. </p>

</div>
</div>
<a id="a272e0c7b90d4591e8e0a13ebb17ca909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272e0c7b90d4591e8e0a13ebb17ca909">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[44/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for arithmetic to JSON. </p>

</div>
</div>
<a id="a4ba55a1d28e2db9a09ba767a4b1f16d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba55a1d28e2db9a09ba767a4b1f16d7">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[45/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1PortableBinaryOutputArchive.html">PortableBinaryOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1BinaryData.html">BinaryData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>bd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving binary data to portable binary. </p>

</div>
</div>
<a id="a246b2dae9307a97ac4d8a44c3c42a0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246b2dae9307a97ac4d8a44c3c42a0e1">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[46/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1PortableBinaryOutputArchive.html">PortableBinaryOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for POD types to portable binary. </p>

</div>
</div>
<a id="a1703ea149fc65a4d7851fa85823287b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1703ea149fc65a4d7851fa85823287b2">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[47/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving SizeTags to XML. </p>

</div>
</div>
<a id="a9a252f7731760e1186c3c552f640fc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a252f7731760e1186c3c552f640fc7b">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[48/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving NVP types to XML. </p>

</div>
</div>
<a id="a63696aa0de3dc95bc27f97bf455d15e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63696aa0de3dc95bc27f97bf455d15e8">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[49/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>saving string to xml </p>

</div>
</div>
<a id="ac6311a745c3a12848550eff8fba71f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6311a745c3a12848550eff8fba71f31">&#9670;&nbsp;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[50/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for POD types to xml. </p>

</div>
</div>
<a id="a073d35d55ad8dc81ce149fb799aab9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073d35d55ad8dc81ce149fb799aab9f0">&#9670;&nbsp;</a></span>CEREAL_SAVE_MINIMAL_FUNCTION_NAME()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt;T&gt;::value, typename <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt;T&gt;::base_type&gt;::type cereal::CEREAL_SAVE_MINIMAL_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for enum types. </p>

</div>
</div>
<a id="a0e33aa2fc1bde7f59e9796f922cee3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e33aa2fc1bde7f59e9796f922cee3b9">&#9670;&nbsp;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::monostate <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializing a std::monostate. </p>

</div>
</div>
<a id="a676a85ac8cfcd512a743f930a10b6770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676a85ac8cfcd512a743f930a10b6770">&#9670;&nbsp;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for raw pointers. </p>
<p>This exists only to throw a static_assert to let users know we don't support raw pointers. </p>

</div>
</div>
<a id="a64ec0a04e5dc57a58de5e78b5a87b8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ec0a04e5dc57a58de5e78b5a87b8d3">&#9670;&nbsp;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing NVP types to binary. </p>
<p>Serializing NVP types to portable binary. </p>

</div>
</div>
<a id="ac5fb9b1468920e7e23cb2817e65fed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fb9b1468920e7e23cb2817e65fed4a">&#9670;&nbsp;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing SizeTags to binary. </p>
<p>Serializing SizeTags to portable binary. </p>

</div>
</div>
<a id="a83c80c9e74c022531318b7df731c1f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c80c9e74c022531318b7df731c1f73">&#9670;&nbsp;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>pair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing for std::pair. </p>

</div>
</div>
<a id="a660edef0c6b018675e109062d459dc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660edef0c6b018675e109062d459dc82">&#9670;&nbsp;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class ... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Types... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing for std::tuple. </p>

</div>
</div>
<a id="a22053a71b907666422b3a281be15bbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22053a71b907666422b3a281be15bbc0">&#9670;&nbsp;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_array&lt;T&gt;::value, void&gt;::type cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for C style arrays. </p>

</div>
</div>
<a id="a1153b7ce7ffbb86e2c81e076a252938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1153b7ce7ffbb86e2c81e076a252938e">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a type is serialized to tear down any special archive state for processing some type </p>

</div>
</div>
<a id="a7ae425e0a66c44b7d39b16d0a6a7f0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae425e0a66c44b7d39b16d0a6a7f0d9">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for JSON archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="a99326c431920835d61e5bfc51b865f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99326c431920835d61e5bfc51b865f22">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="acb582097a98c0558c1a6b3cf0ef52270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb582097a98c0558c1a6b3cf0ef52270">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for SizeTags for JSON archives. </p>

</div>
</div>
<a id="a733225f7be628b7c4dfca463d6a44253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733225f7be628b7c4dfca463d6a44253">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for strings for JSON archives. </p>

</div>
</div>
<a id="a9198bda1f28453a9ead2f8999e5fb449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9198bda1f28453a9ead2f8999e5fb449">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="a5cdc10b14dce9340a8df6cb18ac74554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdc10b14dce9340a8df6cb18ac74554">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, JSONInputArchive &gt;::value, !traits::has_minimal_input_serialization&lt; T, JSONInputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for JSON archives. </p>
<p>Epilogue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="ae0c0c3b1ea7aadc84af34b815bfad6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c0c3b1ea7aadc84af34b815bfad6a6">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a3bec173adc6146ecc712921c2d257ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bec173adc6146ecc712921c2d257ade">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="ab92526cf5d3f4a642d918a027d2e4567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92526cf5d3f4a642d918a027d2e4567">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for SizeTags for JSON archives. </p>
<p>SizeTags are strictly ignored for JSON </p>

</div>
</div>
<a id="aa06f0f66ced9dd9c85377ba61054df94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06f0f66ced9dd9c85377ba61054df94">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for strings for JSON archives. </p>

</div>
</div>
<a id="ad67f92a71f4318dd69e6dec516fe57dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67f92a71f4318dd69e6dec516fe57dd">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="abb6adc568591c0a525f2c16ea5912c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6adc568591c0a525f2c16ea5912c5b">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, JSONOutputArchive &gt;::value, !traits::has_minimal_output_serialization&lt; T, JSONOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for JSON archives (except minimal types) </p>
<p>Epilogue for arithmetic types for JSON archives.</p>
<p>Finishes the node created in the prologue</p>
<p>Minimal types do not start or finish nodes </p>

</div>
</div>
<a id="a70bbce1604367ea45c07dc677186ed64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bbce1604367ea45c07dc677186ed64">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for XML archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="a5d1af5fa5a466ad0cd89513aab823b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1af5fa5a466ad0cd89513aab823b80">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for XML input archives. </p>

</div>
</div>
<a id="ada513bbfcf8c1996e6f7a439f129a208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada513bbfcf8c1996e6f7a439f129a208">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae06e3f89a66231db109db984a87e0cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06e3f89a66231db109db984a87e0cfd">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, XMLInputArchive &gt;::value||traits::has_minimal_input_serialization&lt; T, XMLInputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for XML output archives (except minimal types) </p>

</div>
</div>
<a id="acb1f17a3cae999a9be34889fd2c509a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1f17a3cae999a9be34889fd2c509a0">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for XML archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a906ef65c3ab455598f768431bcd5f37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906ef65c3ab455598f768431bcd5f37d">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for XML output archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="ac3700f36066026da589faa60fed7ca53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3700f36066026da589faa60fed7ca53">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for SizeTags for XML output archives. </p>
<p>SizeTags do not start or finish nodes </p>

</div>
</div>
<a id="a16ca55f7d5556527de1584198ea3c414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ca55f7d5556527de1584198ea3c414">&#9670;&nbsp;</a></span>epilogue() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, XMLOutputArchive &gt;::value||traits::has_minimal_output_serialization&lt; T, XMLOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for XML output archives (except minimal types) </p>
<p>Finishes the node created in the prologue</p>
<p>Minimal types do not start or end nodes </p>

</div>
</div>
<a id="aa227a94792fcb26dd3fd5c4588ed38d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa227a94792fcb26dd3fd5c4588ed38d4">&#9670;&nbsp;</a></span>make_map_item()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType , class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcereal_1_1MapItem.html">MapItem</a>&lt;KeyType, ValueType&gt; cereal::make_map_item </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structcereal_1_1MapItem.html" title="A wrapper around a key and value for serializing data into maps.">MapItem</a> so that human readable archives will group keys and values together. </p>

</div>
</div>
<a id="a8093b5f7cfd618fae6350ef7b2c09453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8093b5f7cfd618fae6350ef7b2c09453">&#9670;&nbsp;</a></span>prologue() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before a type is serialized to set up any special archive state for processing some type</p>
<p>If designing a serializer that needs to set up any kind of special state or output extra information for a type, specialize this function for the archive type and the types that require the extra information. </p>

</div>
</div>
<a id="a6ff01a6c38b02073beb88b56f80b0ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff01a6c38b02073beb88b56f80b0ba7">&#9670;&nbsp;</a></span>prologue() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for deferred data for JSON archives. </p>

</div>
</div>
<a id="ae77f745fd34dd83fa6543e0fa478bdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77f745fd34dd83fa6543e0fa478bdfa">&#9670;&nbsp;</a></span>prologue() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for JSON archives. </p>

</div>
</div>
<a id="accec39647fd17ad5470e42a5c371701c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accec39647fd17ad5470e42a5c371701c">&#9670;&nbsp;</a></span>prologue() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for SizeTags for JSON archives. </p>

</div>
</div>
<a id="a4dde17944a1c24885e39ff673b402841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dde17944a1c24885e39ff673b402841">&#9670;&nbsp;</a></span>prologue() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for strings for JSON archives. </p>

</div>
</div>
<a id="aef075a9d94a926df8ba17689914233e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef075a9d94a926df8ba17689914233e2">&#9670;&nbsp;</a></span>prologue() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="af88fce78fe97297ab4d22a607fee1e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88fce78fe97297ab4d22a607fee1e07">&#9670;&nbsp;</a></span>prologue() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, JSONInputArchive &gt;::value, !traits::has_minimal_input_serialization&lt; T, JSONInputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONInputArchive.html">JSONInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for JSON archives. </p>
<p>Prologue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="ab4eb0997ec3815e2be77c35351d02cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eb0997ec3815e2be77c35351d02cf7">&#9670;&nbsp;</a></span>prologue() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for deferred data for JSON archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="ac267b8915a13f4433fc25aa9d310ee40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac267b8915a13f4433fc25aa9d310ee40">&#9670;&nbsp;</a></span>prologue() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a5f7ec98da774f9e0af596620859d8ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7ec98da774f9e0af596620859d8ccb">&#9670;&nbsp;</a></span>prologue() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for SizeTags for JSON archives. </p>
<p>SizeTags are strictly ignored for JSON, they just indicate that the current node should be made into an array </p>

</div>
</div>
<a id="adacd1c15f7ed1793453e56a675bd0a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacd1c15f7ed1793453e56a675bd0a78">&#9670;&nbsp;</a></span>prologue() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for strings for JSON archives. </p>

</div>
</div>
<a id="a956c4c0578baf265811497c965c4a382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956c4c0578baf265811497c965c4a382">&#9670;&nbsp;</a></span>prologue() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="aba2924cd871a88c20023171f74a68d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2924cd871a88c20023171f74a68d39">&#9670;&nbsp;</a></span>prologue() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;::value, !traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, JSONOutputArchive &gt;::value, !traits::has_minimal_output_serialization&lt; T, JSONOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1JSONOutputArchive.html">JSONOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for JSON archives (except minimal types) </p>
<p>Prologue for arithmetic types for JSON archives.</p>
<p>Starts a new node, named either automatically or by some NVP, that may be given data by the type about to be archived</p>
<p>Minimal types do not start or finish nodes </p>

</div>
</div>
<a id="adf285317856bf80daaa225e171d8d951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf285317856bf80daaa225e171d8d951">&#9670;&nbsp;</a></span>prologue() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for deferred data for XML archives. </p>

</div>
</div>
<a id="a06224101dfaf6979418326a7664e13e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06224101dfaf6979418326a7664e13e2">&#9670;&nbsp;</a></span>prologue() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for XML input archives. </p>

</div>
</div>
<a id="aa25e6485f450649b931e07e0f6384a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25e6485f450649b931e07e0f6384a76">&#9670;&nbsp;</a></span>prologue() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ea2b824c9d003b9e2b36473db1d22c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea2b824c9d003b9e2b36473db1d22c0">&#9670;&nbsp;</a></span>prologue() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_input_serialization, XMLInputArchive &gt;::value||traits::has_minimal_input_serialization&lt; T, XMLInputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLInputArchive.html">XMLInputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for XML input archives (except minimal types) </p>

</div>
</div>
<a id="a6124c7acd34d3740cbedd39559da73c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6124c7acd34d3740cbedd39559da73c3">&#9670;&nbsp;</a></span>prologue() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1DeferredData.html">DeferredData</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for deferred data for XML archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="a2582cc8477f9482910fc5733e13f75f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2582cc8477f9482910fc5733e13f75f7">&#9670;&nbsp;</a></span>prologue() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1NameValuePair.html">NameValuePair</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for XML output archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="adbb541e9594201d78a04cb11ad806ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb541e9594201d78a04cb11ad806ba0">&#9670;&nbsp;</a></span>prologue() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1SizeTag.html">SizeTag</a>&lt; T &gt; <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for SizeTags for XML output archives. </p>
<p>SizeTags do not start or finish nodes </p>

</div>
</div>
<a id="af751c02a4443b571fee21416a4b899c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af751c02a4443b571fee21416a4b899c1">&#9670;&nbsp;</a></span>prologue() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::DisableIf&lt; traits::has_minimal_base_class_serialization&lt; T, traits::has_minimal_output_serialization, XMLOutputArchive &gt;::value||traits::has_minimal_output_serialization&lt; T, XMLOutputArchive &gt;::value &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1XMLOutputArchive.html">XMLOutputArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T <a class="el" href="zconf_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for XML output archives (except minimal types) </p>
<p>Starts a new node, named either automatically or by some NVP, that may be given data by the type about to be archived</p>
<p>Minimal types do not start or end nodes </p>

</div>
</div>
<a id="a02f9cfc9a4055c8a49eb050b02cd3357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f9cfc9a4055c8a49eb050b02cd3357">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::less&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::less. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

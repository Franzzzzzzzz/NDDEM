<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NDDEM: /home/runner/work/NDDEM/NDDEM/src/Dem/cereal/details/traits.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NDDEM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_60f163d56f204d8b3665b29b13f4a292.html">Dem</a></li><li class="navelem"><a class="el" href="dir_77410dce67e7e5aefc43cd65783b34f5.html">cereal</a></li><li class="navelem"><a class="el" href="dir_acc05848374a3463cb01baaf74d7b988.html">details</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">traits.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Internal type trait support.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;typeindex&gt;</code><br />
<code>#include &quot;<a class="el" href="macros_8hpp_source.html">cereal/macros.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="access_8hpp_source.html">cereal/access.hpp</a>&quot;</code><br />
</div>
<p><a href="traits_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1delay__static__assert.html">cereal::traits::detail::delay_static_assert&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to delay a static_assert until template instantiation.  <a href="structcereal_1_1traits_1_1detail_1_1delay__static__assert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1meta__bool__and.html">cereal::traits::detail::meta_bool_and&lt; H, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1meta__bool__and_3_01B_01_4.html">cereal::traits::detail::meta_bool_and&lt; B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1meta__bool__or.html">cereal::traits::detail::meta_bool_or&lt; H, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1meta__bool__or_3_01B_01_4.html">cereal::traits::detail::meta_bool_or&lt; B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1EnableIfHelper.html">cereal::traits::detail::EnableIfHelper&lt; Conditions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1DisableIfHelper.html">cereal::traits::detail::DisableIfHelper&lt; Conditions &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1get__output__from__input.html">cereal::traits::detail::get_output_from_input&lt; InputArchive &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1get__input__from__output.html">cereal::traits::detail::get_input_from_output&lt; OutputArchive &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__member__save.html">cereal::traits::has_member_save&lt; T, A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__member__versioned__save.html">cereal::traits::has_member_versioned_save&lt; T, A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1is__string.html">cereal::traits::detail::is_string&lt; class &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1is__string_3_01std_1_1basic__string_3_01CharT_00_01Traits_00_01Alloc_01_4_01_4.html">cereal::traits::detail::is_string&lt; std::basic_string&lt; CharT, Traits, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1is__minimal__type.html">cereal::traits::is_minimal_type&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1NoConvertBase.html">cereal::traits::detail::NoConvertBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to help strip away conversion wrappers.  <a href="structcereal_1_1traits_1_1detail_1_1NoConvertBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1NoConvertConstRef.html">cereal::traits::detail::NoConvertConstRef&lt; Source &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that prevents implicit conversion.  <a href="structcereal_1_1traits_1_1detail_1_1NoConvertConstRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1NoConvertRef.html">cereal::traits::detail::NoConvertRef&lt; Source &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that prevents implicit conversion.  <a href="structcereal_1_1traits_1_1detail_1_1NoConvertRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1AnyConvert.html">cereal::traits::detail::AnyConvert</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that can implicitly convert to anything else.  <a href="structcereal_1_1traits_1_1detail_1_1AnyConvert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1has__member__load__and__construct__impl.html">cereal::traits::detail::has_member_load_and_construct_impl&lt; T, A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1has__member__versioned__load__and__construct__impl.html">cereal::traits::detail::has_member_versioned_load_and_construct_impl&lt; T, A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__member__load__and__construct.html">cereal::traits::has_member_load_and_construct&lt; T, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member load and construct check.  <a href="structcereal_1_1traits_1_1has__member__load__and__construct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__member__versioned__load__and__construct.html">cereal::traits::has_member_versioned_load_and_construct&lt; T, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member load and construct check (versioned)  <a href="structcereal_1_1traits_1_1has__member__versioned__load__and__construct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">cereal::traits::has_load_and_construct&lt; T, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non member load and construct check.  <a href="structcereal_1_1traits_1_1has__load__and__construct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__member__split.html">cereal::traits::has_member_split&lt; T, InputArchive, OutputArchive &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__non__member__split.html">cereal::traits::has_non_member_split&lt; T, InputArchive, OutputArchive &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__invalid__output__versioning.html">cereal::traits::has_invalid_output_versioning&lt; T, OutputArchive &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__invalid__input__versioning.html">cereal::traits::has_invalid_input_versioning&lt; T, InputArchive &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1count__specializations.html">cereal::traits::detail::count_specializations&lt; T, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of specializations detected.  <a href="structcereal_1_1traits_1_1detail_1_1count__specializations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1is__specialized.html">cereal::traits::is_specialized&lt; T, A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any specialization exists for a type.  <a href="structcereal_1_1traits_1_1is__specialized.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">cereal::traits::has_minimal_output_serialization&lt; T, OutputArchive &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">cereal::traits::has_minimal_input_serialization&lt; T, InputArchive &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1count__output__serializers.html">cereal::traits::detail::count_output_serializers&lt; T, OutputArchive &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of output serialization functions available.  <a href="structcereal_1_1traits_1_1detail_1_1count__output__serializers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">cereal::traits::is_output_serializable&lt; T, OutputArchive &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1count__input__serializers.html">cereal::traits::detail::count_input_serializers&lt; T, InputArchive &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of input serialization functions available.  <a href="structcereal_1_1traits_1_1detail_1_1count__input__serializers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">cereal::traits::is_input_serializable&lt; T, InputArchive &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1base__class__id.html">cereal::traits::detail::base_class_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1base__class__id__hash.html">cereal::traits::detail::base_class_id_hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1BaseCastBase.html">cereal::traits::detail::BaseCastBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base type for base class casting.  <a href="structcereal_1_1traits_1_1detail_1_1BaseCastBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1get__base__class_3_01Cast_3_01Base_01_4_01_4.html">cereal::traits::detail::get_base_class&lt; Cast&lt; Base &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1has__minimal__base__class__serialization__impl.html">cereal::traits::detail::has_minimal_base_class_serialization_impl&lt; Cast, Test, Archive, IsBaseCast &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class cast, behave as the test.  <a href="structcereal_1_1traits_1_1detail_1_1has__minimal__base__class__serialization__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1has__minimal__base__class__serialization__impl_3_01Cast_00_097b19a5d12c91692c0238b4e5b9d7e3a.html">cereal::traits::detail::has_minimal_base_class_serialization_impl&lt; Cast, Test, Archive, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not a base class cast.  <a href="structcereal_1_1traits_1_1detail_1_1has__minimal__base__class__serialization__impl_3_01Cast_00_097b19a5d12c91692c0238b4e5b9d7e3a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">cereal::traits::has_minimal_base_class_serialization&lt; Cast, Test, Archive &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if the base class used in a cast has a minimal serialization.  <a href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1detail_1_1shared__from__this__wrapper.html">cereal::traits::detail::shared_from_this_wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1has__shared__from__this.html">cereal::traits::has_shared_from_this&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if T or any base class of T has inherited from std::enable_shared_from_this.  <a href="structcereal_1_1traits_1_1has__shared__from__this.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1get__shared__from__this__base.html">cereal::traits::get_shared_from_this_base&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the base class of T which inherited from std::enable_shared_from_this.  <a href="structcereal_1_1traits_1_1get__shared__from__this__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1strip__minimal.html">cereal::traits::strip_minimal&lt; T, IsCerealMinimalTrait &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the true type from something possibly wrapped in a cereal NoConvert.  <a href="structcereal_1_1traits_1_1strip__minimal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1strip__minimal_3_01T_00_01true_01_4.html">cereal::traits::strip_minimal&lt; T, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for types wrapped in a NoConvert.  <a href="structcereal_1_1traits_1_1strip__minimal_3_01T_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1is__default__constructible.html">cereal::traits::is_default_constructible&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the class T can be default constructed by <a class="el" href="classcereal_1_1access.html" title="A class that can be made a friend to give cereal access to non public functions.">cereal::access</a>.  <a href="structcereal_1_1traits_1_1is__default__constructible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1is__same__archive.html">cereal::traits::is_same_archive&lt; ArchiveT, CerealArchiveT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the provided archive type is equal to some cereal archive type.  <a href="structcereal_1_1traits_1_1is__same__archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1TextArchive.html">cereal::traits::TextArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type traits only struct used to mark an archive as human readable (text based)  <a href="structcereal_1_1traits_1_1TextArchive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1traits_1_1is__text__archive.html">cereal::traits::is_text_archive&lt; A &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an archive is a text archive (human readable)  <a href="structcereal_1_1traits_1_1is__text__archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1detail_1_1Construct.html">cereal::detail::Construct&lt; T, A, Member, MemberVersioned, NonMember, NonMemberVersioned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1detail_1_1Construct_3_01T_00_01A_00_01false_00_01false_00_01false_00_01false_01_4.html">cereal::detail::Construct&lt; T, A, false, false, false, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1detail_1_1Construct_3_01T_00_01A_00_01true_00_01false_00_01false_00_01false_01_4.html">cereal::detail::Construct&lt; T, A, true, false, false, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1detail_1_1Construct_3_01T_00_01A_00_01false_00_01true_00_01false_00_01false_01_4.html">cereal::detail::Construct&lt; T, A, false, true, false, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1detail_1_1Construct_3_01T_00_01A_00_01false_00_01false_00_01true_00_01false_01_4.html">cereal::detail::Construct&lt; T, A, false, false, true, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1detail_1_1Construct_3_01T_00_01A_00_01false_00_01false_00_01false_00_01true_01_4.html">cereal::detail::Construct&lt; T, A, false, false, false, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecereal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal.html">cereal</a></td></tr>
<tr class="memdesc:namespacecereal"><td class="mdescLeft">&#160;</td><td class="mdescRight">in certain simple scenarios. They should probably not be used if maximizing performance is the main objective. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html">cereal::traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1traits_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits_1_1detail.html">cereal::traits::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1detail.html">cereal::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a039bc7d4a3e8994d3fd7eedf5cae1666"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a039bc7d4a3e8994d3fd7eedf5cae1666">CEREAL_SETUP_ARCHIVE_TRAITS</a>(InputArchive,  OutputArchive)</td></tr>
<tr class="memdesc:a039bc7d4a3e8994d3fd7eedf5cae1666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up traits that relate an input archive to an output archive.  <a href="traits_8hpp.html#a039bc7d4a3e8994d3fd7eedf5cae1666">More...</a><br /></td></tr>
<tr class="separator:a039bc7d4a3e8994d3fd7eedf5cae1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8638d8b3af51cf4f6bed0ed2dae54928"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a8638d8b3af51cf4f6bed0ed2dae54928">CEREAL_MAKE_VERSIONED_TEST</a>&#160;&#160;&#160;,0</td></tr>
<tr class="memdesc:a8638d8b3af51cf4f6bed0ed2dae54928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to convert a MAKE_HAS_XXX macro into a versioned variant.  <a href="traits_8hpp.html#a8638d8b3af51cf4f6bed0ed2dae54928">More...</a><br /></td></tr>
<tr class="separator:a8638d8b3af51cf4f6bed0ed2dae54928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fc70d51b619b785c0741568f2012ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#ad2fc70d51b619b785c0741568f2012ba">CEREAL_MAKE_HAS_MEMBER_TEST</a>(name,  test_name,  versioned)</td></tr>
<tr class="memdesc:ad2fc70d51b619b785c0741568f2012ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test for whether a non const member function exists.  <a href="traits_8hpp.html#ad2fc70d51b619b785c0741568f2012ba">More...</a><br /></td></tr>
<tr class="separator:ad2fc70d51b619b785c0741568f2012ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31f4783772a7f6a3048a793090715cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#af31f4783772a7f6a3048a793090715cf">CEREAL_MAKE_HAS_NON_MEMBER_TEST</a>(test_name,  func,  versioned)</td></tr>
<tr class="memdesc:af31f4783772a7f6a3048a793090715cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test for whether a non const non-member function exists.  <a href="traits_8hpp.html#af31f4783772a7f6a3048a793090715cf">More...</a><br /></td></tr>
<tr class="separator:af31f4783772a7f6a3048a793090715cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669b39fde8f86acef9e5b1470ceb0364"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a669b39fde8f86acef9e5b1470ceb0364">CEREAL_MAKE_HAS_MEMBER_SAVE_IMPL</a>(test_name,  versioned)</td></tr>
<tr class="memdesc:a669b39fde8f86acef9e5b1470ceb0364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test for whether a member save function exists.  <a href="traits_8hpp.html#a669b39fde8f86acef9e5b1470ceb0364">More...</a><br /></td></tr>
<tr class="separator:a669b39fde8f86acef9e5b1470ceb0364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be76cc82813adfc110f793e37636fb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a5be76cc82813adfc110f793e37636fb1">CEREAL_MAKE_HAS_NON_MEMBER_SAVE_TEST</a>(test_name,  versioned)</td></tr>
<tr class="memdesc:a5be76cc82813adfc110f793e37636fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test for whether a non-member save function exists.  <a href="traits_8hpp.html#a5be76cc82813adfc110f793e37636fb1">More...</a><br /></td></tr>
<tr class="separator:a5be76cc82813adfc110f793e37636fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9d56e1b4254790186b1565796fdd35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a3d9d56e1b4254790186b1565796fdd35">CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_IMPL</a>(test_name,  versioned)</td></tr>
<tr class="memdesc:a3d9d56e1b4254790186b1565796fdd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates implementation details for whether a member save_minimal function exists.  <a href="traits_8hpp.html#a3d9d56e1b4254790186b1565796fdd35">More...</a><br /></td></tr>
<tr class="separator:a3d9d56e1b4254790186b1565796fdd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab60653db33c8898506326963f8a7211"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#aab60653db33c8898506326963f8a7211">CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_HELPERS_IMPL</a>(test_name,  versioned)</td></tr>
<tr class="memdesc:aab60653db33c8898506326963f8a7211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates helpers for minimal save functions.  <a href="traits_8hpp.html#aab60653db33c8898506326963f8a7211">More...</a><br /></td></tr>
<tr class="separator:aab60653db33c8898506326963f8a7211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f583ea76bb88656995fa4d5d5e9ade"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a33f583ea76bb88656995fa4d5d5e9ade">CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_TEST</a>(test_name)</td></tr>
<tr class="memdesc:a33f583ea76bb88656995fa4d5d5e9ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test for whether a member save_minimal function exists.  <a href="traits_8hpp.html#a33f583ea76bb88656995fa4d5d5e9ade">More...</a><br /></td></tr>
<tr class="separator:a33f583ea76bb88656995fa4d5d5e9ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eb2173790b30144a419f33afcd2710"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#ae7eb2173790b30144a419f33afcd2710">CEREAL_MAKE_HAS_NON_MEMBER_SAVE_MINIMAL_TEST</a>(test_name,  versioned)</td></tr>
<tr class="memdesc:ae7eb2173790b30144a419f33afcd2710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test for whether a non-member save_minimal function exists.  <a href="traits_8hpp.html#ae7eb2173790b30144a419f33afcd2710">More...</a><br /></td></tr>
<tr class="separator:ae7eb2173790b30144a419f33afcd2710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41354a9a797549bb6802c0f16435f675"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a41354a9a797549bb6802c0f16435f675">CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_IMPL</a>(test_name,  versioned)</td></tr>
<tr class="memdesc:a41354a9a797549bb6802c0f16435f675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test for whether a member load_minimal function exists.  <a href="traits_8hpp.html#a41354a9a797549bb6802c0f16435f675">More...</a><br /></td></tr>
<tr class="separator:a41354a9a797549bb6802c0f16435f675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d829a1189314b4adb3b1f6f72d94151"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a4d829a1189314b4adb3b1f6f72d94151">CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_HELPERS_IMPL</a>(load_test_name,  save_test_name,  save_test_prefix,  versioned)</td></tr>
<tr class="memdesc:a4d829a1189314b4adb3b1f6f72d94151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates helpers for minimal load functions.  <a href="traits_8hpp.html#a4d829a1189314b4adb3b1f6f72d94151">More...</a><br /></td></tr>
<tr class="separator:a4d829a1189314b4adb3b1f6f72d94151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4497ffc80b9053f731b781d740b98af2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a4497ffc80b9053f731b781d740b98af2">CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_TEST</a>(load_test_name,  load_test_prefix)</td></tr>
<tr class="memdesc:a4497ffc80b9053f731b781d740b98af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test for whether a member load_minimal function exists.  <a href="traits_8hpp.html#a4497ffc80b9053f731b781d740b98af2">More...</a><br /></td></tr>
<tr class="separator:a4497ffc80b9053f731b781d740b98af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99298ef5f4678723f35d175291eb5770"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a99298ef5f4678723f35d175291eb5770">CEREAL_MAKE_HAS_NON_MEMBER_LOAD_MINIMAL_TEST</a>(test_name,  save_name,  versioned)</td></tr>
<tr class="memdesc:a99298ef5f4678723f35d175291eb5770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test for whether a non-member load_minimal function exists.  <a href="traits_8hpp.html#a99298ef5f4678723f35d175291eb5770">More...</a><br /></td></tr>
<tr class="separator:a99298ef5f4678723f35d175291eb5770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a75d150c050c8a44ab1d9d2b85bba6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a65a75d150c050c8a44ab1d9d2b85bba6">CEREAL_MAKE_HAS_NON_MEMBER_LOAD_AND_CONSTRUCT_TEST</a>(test_name,  versioned)</td></tr>
<tr class="memdesc:a65a75d150c050c8a44ab1d9d2b85bba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a test for whether a non-member load_and_construct specialization exists.  <a href="traits_8hpp.html#a65a75d150c050c8a44ab1d9d2b85bba6">More...</a><br /></td></tr>
<tr class="separator:a65a75d150c050c8a44ab1d9d2b85bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ec65e257576ae208d6a71cf01c4258"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a33ec65e257576ae208d6a71cf01c4258">CEREAL_MAKE_IS_SPECIALIZED_IMPL</a>(name)</td></tr>
<tr class="memdesc:a33ec65e257576ae208d6a71cf01c4258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a test for a cereal::specialization entry.  <a href="traits_8hpp.html#a33ec65e257576ae208d6a71cf01c4258">More...</a><br /></td></tr>
<tr class="separator:a33ec65e257576ae208d6a71cf01c4258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6519141d71272bbe5db25d01d175ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a7e6519141d71272bbe5db25d01d175ad">CEREAL_MAKE_IS_SPECIALIZED_ASSERT</a>(name,  versioned_name,  print_name,  spec_name)</td></tr>
<tr class="memdesc:a7e6519141d71272bbe5db25d01d175ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the static assertion for some specialization.  <a href="traits_8hpp.html#a7e6519141d71272bbe5db25d01d175ad">More...</a><br /></td></tr>
<tr class="separator:a7e6519141d71272bbe5db25d01d175ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af566f627f0de18c31e2bbb21a01cce70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#af566f627f0de18c31e2bbb21a01cce70">CEREAL_MAKE_IS_SPECIALIZED</a>(name,  versioned_name,  spec_name)</td></tr>
<tr class="memdesc:af566f627f0de18c31e2bbb21a01cce70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a test for specialization for versioned and unversioned functions.  <a href="traits_8hpp.html#af566f627f0de18c31e2bbb21a01cce70">More...</a><br /></td></tr>
<tr class="separator:af566f627f0de18c31e2bbb21a01cce70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29490687675183194498a843f7beeb8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a29490687675183194498a843f7beeb8b">CEREAL_ARCHIVE_RESTRICT</a>(INTYPE,  OUTTYPE)&#160;&#160;&#160;    typename std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__same__archive.html">cereal::traits::is_same_archive</a>&lt;Archive, INTYPE&gt;::<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> || <a class="el" href="structcereal_1_1traits_1_1is__same__archive.html">cereal::traits::is_same_archive</a>&lt;Archive, OUTTYPE&gt;::<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a>, void&gt;::type</td></tr>
<tr class="memdesc:a29490687675183194498a843f7beeb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro to use to restrict which types of archives your function will work for.  <a href="traits_8hpp.html#a29490687675183194498a843f7beeb8b">More...</a><br /></td></tr>
<tr class="separator:a29490687675183194498a843f7beeb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a32b99987a136bc56cb30707526c9ba2f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">cereal::traits::yes</a> = std::true_type</td></tr>
<tr class="separator:a32b99987a136bc56cb30707526c9ba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22419d99e8d081eef29f2f99e5cb54c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">cereal::traits::no</a> = std::false_type</td></tr>
<tr class="separator:ad22419d99e8d081eef29f2f99e5cb54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e5f793ba5a1b3d2fd674d7334b12bd"><td class="memTemplParams" colspan="2">template&lt;bool ... Conditions&gt; </td></tr>
<tr class="memitem:a42e5f793ba5a1b3d2fd674d7334b12bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a42e5f793ba5a1b3d2fd674d7334b12bd">EnableIf</a> = typename detail::EnableIfHelper&lt; Conditions... &gt;::type</td></tr>
<tr class="memdesc:a42e5f793ba5a1b3d2fd674d7334b12bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a way to enable a function if conditions are met.  <a href="traits_8hpp.html#a42e5f793ba5a1b3d2fd674d7334b12bd">More...</a><br /></td></tr>
<tr class="separator:a42e5f793ba5a1b3d2fd674d7334b12bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07719740a7cec6692b44244201a92603"><td class="memTemplParams" colspan="2">template&lt;bool ... Conditions&gt; </td></tr>
<tr class="memitem:a07719740a7cec6692b44244201a92603"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#a07719740a7cec6692b44244201a92603">DisableIf</a> = typename detail::DisableIfHelper&lt; Conditions... &gt;::type</td></tr>
<tr class="memdesc:a07719740a7cec6692b44244201a92603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a way to disable a function if conditions are met.  <a href="traits_8hpp.html#a07719740a7cec6692b44244201a92603">More...</a><br /></td></tr>
<tr class="separator:a07719740a7cec6692b44244201a92603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae185068d4b912e2d20c03d35ab553d59"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:ae185068d4b912e2d20c03d35ab553d59"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits_1_1detail.html#ae185068d4b912e2d20c03d35ab553d59">cereal::traits::detail::decay_archive</a> = typename std::decay&lt; typename strip_minimal&lt; A &gt;::type &gt;::type</td></tr>
<tr class="memdesc:ae185068d4b912e2d20c03d35ab553d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all qualifiers and minimal wrappers from an archive.  <a href="namespacecereal_1_1traits_1_1detail.html#ae185068d4b912e2d20c03d35ab553d59">More...</a><br /></td></tr>
<tr class="separator:ae185068d4b912e2d20c03d35ab553d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aafd74e5beca7e112de8b2e20ef41d973"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits_1_1detail.html#aafd74e5beca7e112de8b2e20ef41d973">cereal::traits::detail::sfinae</a> </td></tr>
<tr class="memdesc:aafd74e5beca7e112de8b2e20ef41d973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for SFINAE Enablers.  <a href="namespacecereal_1_1traits_1_1detail.html#aafd74e5beca7e112de8b2e20ef41d973">More...</a><br /></td></tr>
<tr class="separator:aafd74e5beca7e112de8b2e20ef41d973"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a272f835b66fc9503a8c832007612a7f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a272f835b66fc9503a8c832007612a7f1">cereal::traits::CEREAL_MAKE_HAS_MEMBER_TEST</a> (serialize, serialize,)</td></tr>
<tr class="separator:a272f835b66fc9503a8c832007612a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4330c797a0db80059c74ce0d298cf7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#aba4330c797a0db80059c74ce0d298cf7">cereal::traits::CEREAL_MAKE_HAS_MEMBER_TEST</a> (serialize, versioned_serialize, <a class="el" href="traits_8hpp.html#a8638d8b3af51cf4f6bed0ed2dae54928">CEREAL_MAKE_VERSIONED_TEST</a>)</td></tr>
<tr class="separator:aba4330c797a0db80059c74ce0d298cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84537b1c09daf1cfb31c687d3844336c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a84537b1c09daf1cfb31c687d3844336c">cereal::traits::CEREAL_MAKE_HAS_NON_MEMBER_TEST</a> (serialize, <a class="el" href="macros_8hpp.html#ad6b40d3472fa3d7f2148657c5bd6a07a">CEREAL_SERIALIZE_FUNCTION_NAME</a>,)</td></tr>
<tr class="separator:a84537b1c09daf1cfb31c687d3844336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4703a037e82b58fa568ea1a869932b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a1e4703a037e82b58fa568ea1a869932b">cereal::traits::CEREAL_MAKE_HAS_NON_MEMBER_TEST</a> (versioned_serialize, <a class="el" href="macros_8hpp.html#ad6b40d3472fa3d7f2148657c5bd6a07a">CEREAL_SERIALIZE_FUNCTION_NAME</a>, <a class="el" href="traits_8hpp.html#a8638d8b3af51cf4f6bed0ed2dae54928">CEREAL_MAKE_VERSIONED_TEST</a>)</td></tr>
<tr class="separator:a1e4703a037e82b58fa568ea1a869932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91965ae6af453b52a6479d4e9a8e32f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a91965ae6af453b52a6479d4e9a8e32f9">cereal::traits::CEREAL_MAKE_HAS_MEMBER_TEST</a> (load, load,)</td></tr>
<tr class="separator:a91965ae6af453b52a6479d4e9a8e32f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be14e72c1af859d2f57da9c6bee521c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a5be14e72c1af859d2f57da9c6bee521c">cereal::traits::CEREAL_MAKE_HAS_MEMBER_TEST</a> (load, versioned_load, <a class="el" href="traits_8hpp.html#a8638d8b3af51cf4f6bed0ed2dae54928">CEREAL_MAKE_VERSIONED_TEST</a>)</td></tr>
<tr class="separator:a5be14e72c1af859d2f57da9c6bee521c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba309d0c0b8990cc41264a735f6fe8a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#aba309d0c0b8990cc41264a735f6fe8a0">cereal::traits::CEREAL_MAKE_HAS_NON_MEMBER_TEST</a> (load, <a class="el" href="macros_8hpp.html#a854de4fbe2b80753b27264b7dda740e8">CEREAL_LOAD_FUNCTION_NAME</a>,)</td></tr>
<tr class="separator:aba309d0c0b8990cc41264a735f6fe8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ef3b068e4c18caaf90c2d3adb3b2c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a83ef3b068e4c18caaf90c2d3adb3b2c0">cereal::traits::CEREAL_MAKE_HAS_NON_MEMBER_TEST</a> (versioned_load, <a class="el" href="macros_8hpp.html#a854de4fbe2b80753b27264b7dda740e8">CEREAL_LOAD_FUNCTION_NAME</a>, <a class="el" href="traits_8hpp.html#a8638d8b3af51cf4f6bed0ed2dae54928">CEREAL_MAKE_VERSIONED_TEST</a>)</td></tr>
<tr class="separator:a83ef3b068e4c18caaf90c2d3adb3b2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b1b50cefc0d028cae13d4bb85b0d45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits_1_1detail.html#a57b1b50cefc0d028cae13d4bb85b0d45">cereal::traits::detail::CEREAL_MAKE_IS_SPECIALIZED_IMPL</a> (member_serialize)</td></tr>
<tr class="separator:a57b1b50cefc0d028cae13d4bb85b0d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d52f02ddb07b4750b1d342db245610"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits_1_1detail.html#aa3d52f02ddb07b4750b1d342db245610">cereal::traits::detail::CEREAL_MAKE_IS_SPECIALIZED_IMPL</a> (member_load_save)</td></tr>
<tr class="separator:aa3d52f02ddb07b4750b1d342db245610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8074cb2fe6eb50846f5adf3edfcbcd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits_1_1detail.html#aa8074cb2fe6eb50846f5adf3edfcbcd2">cereal::traits::detail::CEREAL_MAKE_IS_SPECIALIZED_IMPL</a> (member_load_save_minimal)</td></tr>
<tr class="separator:aa8074cb2fe6eb50846f5adf3edfcbcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e103445b8259599a8c5a2d784dc0ca0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits_1_1detail.html#a8e103445b8259599a8c5a2d784dc0ca0">cereal::traits::detail::CEREAL_MAKE_IS_SPECIALIZED_IMPL</a> (non_member_serialize)</td></tr>
<tr class="separator:a8e103445b8259599a8c5a2d784dc0ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c27264ebd40cb17fbdbb65fefef319"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits_1_1detail.html#a64c27264ebd40cb17fbdbb65fefef319">cereal::traits::detail::CEREAL_MAKE_IS_SPECIALIZED_IMPL</a> (non_member_load_save)</td></tr>
<tr class="separator:a64c27264ebd40cb17fbdbb65fefef319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57714ba26e46777c7acddca859a047ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits_1_1detail.html#a57714ba26e46777c7acddca859a047ba">cereal::traits::detail::CEREAL_MAKE_IS_SPECIALIZED_IMPL</a> (non_member_load_save_minimal)</td></tr>
<tr class="separator:a57714ba26e46777c7acddca859a047ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e44b59c6260570584a890efa520a8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a37e44b59c6260570584a890efa520a8b">cereal::traits::CEREAL_MAKE_IS_SPECIALIZED</a> (member_serialize, member_versioned_serialize, member_serialize)</td></tr>
<tr class="separator:a37e44b59c6260570584a890efa520a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b352be989824571c05f6dc304d4df71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a6b352be989824571c05f6dc304d4df71">cereal::traits::CEREAL_MAKE_IS_SPECIALIZED</a> (non_member_serialize, non_member_versioned_serialize, non_member_serialize)</td></tr>
<tr class="separator:a6b352be989824571c05f6dc304d4df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb4eb583516b360022a255f9703b96d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#adcb4eb583516b360022a255f9703b96d">cereal::traits::CEREAL_MAKE_IS_SPECIALIZED</a> (member_save, member_versioned_save, member_load_save)</td></tr>
<tr class="separator:adcb4eb583516b360022a255f9703b96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2f0c0f9cdf1701d6be30bfa69107d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a6d2f0c0f9cdf1701d6be30bfa69107d3">cereal::traits::CEREAL_MAKE_IS_SPECIALIZED</a> (non_member_save, non_member_versioned_save, non_member_load_save)</td></tr>
<tr class="separator:a6d2f0c0f9cdf1701d6be30bfa69107d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe788b8d27ce8494df42e108624d387"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#afbe788b8d27ce8494df42e108624d387">cereal::traits::CEREAL_MAKE_IS_SPECIALIZED</a> (member_load, member_versioned_load, member_load_save)</td></tr>
<tr class="separator:afbe788b8d27ce8494df42e108624d387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6314b143f33f837572c766b8822b5d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#ac6314b143f33f837572c766b8822b5d2">cereal::traits::CEREAL_MAKE_IS_SPECIALIZED</a> (non_member_load, non_member_versioned_load, non_member_load_save)</td></tr>
<tr class="separator:ac6314b143f33f837572c766b8822b5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d88853aa20506f95abd46b95e40bac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a04d88853aa20506f95abd46b95e40bac">cereal::traits::CEREAL_MAKE_IS_SPECIALIZED</a> (member_save_minimal, member_versioned_save_minimal, member_load_save_minimal)</td></tr>
<tr class="separator:a04d88853aa20506f95abd46b95e40bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa492e93c41a9b6fb524b68f925f489a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#aa492e93c41a9b6fb524b68f925f489a4">cereal::traits::CEREAL_MAKE_IS_SPECIALIZED</a> (non_member_save_minimal, non_member_versioned_save_minimal, non_member_load_save_minimal)</td></tr>
<tr class="separator:aa492e93c41a9b6fb524b68f925f489a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5b663e3c4b1bc658070b443829e669"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a6a5b663e3c4b1bc658070b443829e669">cereal::traits::CEREAL_MAKE_IS_SPECIALIZED</a> (member_load_minimal, member_versioned_load_minimal, member_load_save_minimal)</td></tr>
<tr class="separator:a6a5b663e3c4b1bc658070b443829e669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e21033492e984bb43e0ac0ee72fabe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html#a32e21033492e984bb43e0ac0ee72fabe">cereal::traits::CEREAL_MAKE_IS_SPECIALIZED</a> (non_member_load_minimal, non_member_versioned_load_minimal, non_member_load_save_minimal)</td></tr>
<tr class="separator:a32e21033492e984bb43e0ac0ee72fabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac1c99b1883f356bf4cbfda710ee68e91"><td class="memItemLeft" align="right" valign="top">static const detail::sfinae&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="traits_8hpp.html#ac1c99b1883f356bf4cbfda710ee68e91">sfinae</a> = {}</td></tr>
<tr class="memdesc:ac1c99b1883f356bf4cbfda710ee68e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used as the default value for EnableIf and DisableIf template parameters.  <a href="traits_8hpp.html#ac1c99b1883f356bf4cbfda710ee68e91">More...</a><br /></td></tr>
<tr class="separator:ac1c99b1883f356bf4cbfda710ee68e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Internal type trait support. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a29490687675183194498a843f7beeb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29490687675183194498a843f7beeb8b">&#9670;&nbsp;</a></span>CEREAL_ARCHIVE_RESTRICT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_ARCHIVE_RESTRICT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">INTYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OUTTYPE&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    typename std::enable_if&lt;<a class="el" href="structcereal_1_1traits_1_1is__same__archive.html">cereal::traits::is_same_archive</a>&lt;Archive, INTYPE&gt;::<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> || <a class="el" href="structcereal_1_1traits_1_1is__same__archive.html">cereal::traits::is_same_archive</a>&lt;Archive, OUTTYPE&gt;::<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a>, void&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A macro to use to restrict which types of archives your function will work for. </p>
<p>This requires you to have a template class parameter named Archive and replaces the void return type for your function.</p>
<p>INTYPE refers to the input archive type you wish to restrict on. OUTTYPE refers to the output archive type you wish to restrict on.</p>
<p>For example, if we want to limit a serialize to only work with binary serialization:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Archive&gt;</div>
<div class="line"><a class="code" href="traits_8hpp.html#a29490687675183194498a843f7beeb8b">CEREAL_ARCHIVE_RESTRICT</a>(BinaryInputArchive, BinaryOutputArchive)</div>
<div class="line"><a class="code" href="namespacecereal.html#a02f9cfc9a4055c8a49eb050b02cd3357">serialize</a>( Archive &amp; ar, MyCoolType &amp; m )</div>
<div class="line">{</div>
<div class="line">  ar &amp; m;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacecereal_html_a02f9cfc9a4055c8a49eb050b02cd3357"><div class="ttname"><a href="namespacecereal.html#a02f9cfc9a4055c8a49eb050b02cd3357">cereal::serialize</a></div><div class="ttdeci">void serialize(Archive &amp;, std::less&lt; T &gt; &amp;)</div><div class="ttdoc">Saving for std::less.</div><div class="ttdef"><b>Definition:</b> functional.hpp:39</div></div>
<div class="ttc" id="atraits_8hpp_html_a29490687675183194498a843f7beeb8b"><div class="ttname"><a href="traits_8hpp.html#a29490687675183194498a843f7beeb8b">CEREAL_ARCHIVE_RESTRICT</a></div><div class="ttdeci">#define CEREAL_ARCHIVE_RESTRICT(INTYPE, OUTTYPE)</div><div class="ttdoc">A macro to use to restrict which types of archives your function will work for.</div><div class="ttdef"><b>Definition:</b> traits.hpp:1315</div></div>
</div><!-- fragment --><p>If you need to do more restrictions in your enable_if, you will need to do this by hand. </p>

</div>
</div>
<a id="a4d829a1189314b4adb3b1f6f72d94151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d829a1189314b4adb3b1f6f72d94151">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_HELPERS_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_HELPERS_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">load_test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">save_test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">save_test_prefix, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a>                                                                                                      \</div>
<div class="line">    {                                                                                                                     \</div>
<div class="line">      template &lt;class T, class A, bool Valid&gt;                                                                             \</div>
<div class="line">      struct has_member_##load_test_name##_wrapper : std::false_type {};                                                  \</div>
<div class="line">                                                                                                                          \</div>
<div class="line">      template &lt;class T, class A&gt;                                                                                         \</div>
<div class="line">      struct has_member_##load_test_name##_wrapper&lt;T, A, true&gt;                                                            \</div>
<div class="line">      {                                                                                                                   \</div>
<div class="line">        using AOut = <span class="keyword">typename</span> <a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">detail::get_output_from_input&lt;A&gt;::type</a>;                                                     \</div>
<div class="line">                                                                                                                          \</div>
<div class="line">        static_assert( has_member_##save_test_prefix##<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">_minimal&lt;T, AOut&gt;::value</a>,                                           \</div>
<div class="line">          <span class="stringliteral">&quot;cereal detected member &quot;</span> #load_test_name <span class="stringliteral">&quot; but no valid member &quot;</span> #save_test_name <span class="stringliteral">&quot;. \n &quot;</span>                       \</div>
<div class="line">          <span class="stringliteral">&quot;cannot evaluate correctness of &quot;</span> #load_test_name <span class="stringliteral">&quot; without valid &quot;</span> #save_test_name <span class="stringliteral">&quot;.&quot;</span> );                      \</div>
<div class="line">                                                                                                                          \</div>
<div class="line">        using SaveType = <span class="keyword">typename</span> detail::get_member_##save_test_prefix##<a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">_minimal_type&lt;T, AOut, true&gt;::type</a>;              \</div>
<div class="line">        const <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> = has_member_##load_test_name##<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">_impl&lt;T, A&gt;::value</a>;                                        \</div>
<div class="line">        const <span class="keyword">static</span> <span class="keywordtype">bool</span> valid = has_member_##load_test_name##<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">_type_impl&lt;T, A, SaveType&gt;::value</a>;                         \</div>
<div class="line">                                                                                                                          \</div>
<div class="line">        static_assert( valid || !value, <span class="stringliteral">&quot;cereal detected different or invalid types in corresponding member &quot;</span>             \</div>
<div class="line">            #load_test_name <span class="stringliteral">&quot; and &quot;</span> #save_test_name <span class="stringliteral">&quot; functions. \n &quot;</span>                                                     \</div>
<div class="line">            <span class="stringliteral">&quot;the paramater to &quot;</span> #load_test_name <span class="stringliteral">&quot; must be a constant reference to the type that &quot;</span>                         \</div>
<div class="line">            #save_test_name <span class="stringliteral">&quot; returns.&quot;</span> );                                                                                \</div>
<div class="line">      };                                                                                                                  \</div>
<div class="line">    } <span class="comment">/* end namespace detail */</span></div>
<div class="ttc" id="anamespacecereal_1_1bitset__detail_html_a4f5825a3267dd05e798bed76cf7e29cc"><div class="ttname"><a href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">cereal::bitset_detail::type</a></div><div class="ttdeci">type</div><div class="ttdoc">The type the bitset is encoded with.</div><div class="ttdef"><b>Definition:</b> bitset.hpp:44</div></div>
<div class="ttc" id="anamespacedetail_html"><div class="ttname"><a href="namespacedetail.html">detail</a></div><div class="ttdoc">detail namespace with internal helper functions</div><div class="ttdef"><b>Definition:</b> json.hpp:260</div></div>
<div class="ttc" id="apointer_8h_html_a32aff7c6c4cd253fdf6563677afab5ce"><div class="ttname"><a href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a></div><div class="ttdeci">const GenericPointer&lt; typename T::ValueType &gt; T2 value</div><div class="ttdef"><b>Definition:</b> pointer.h:1282</div></div>
</div><!-- fragment -->
<p>Creates helpers for minimal load functions. </p>
<p>The has_member_*_wrapper structs ensure that the load and save types for the requested function type match appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">load_test_name</td><td>The name to give the test (e.g. load_minimal or versioned_load_minimal) </td></tr>
    <tr><td class="paramname">save_test_name</td><td>The name to give the test (e.g. save_minimal or versioned_save_minimal, should match the load name. </td></tr>
    <tr><td class="paramname">save_test_prefix</td><td>The name to give the test (e.g. save_minimal or versioned_save_minimal, should match the load name, without the trailing "_minimal" (e.g. save or versioned_save). Needed because the preprocessor is an abomination. </td></tr>
    <tr><td class="paramname">versioned</td><td>Either blank or the macro CEREAL_MAKE_VERSIONED_TEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41354a9a797549bb6802c0f16435f675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41354a9a797549bb6802c0f16435f675">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a>                                                                    \</div>
<div class="line">    {                                                                                   \</div>
<div class="line">      template &lt;class T, class A&gt;                                                       \</div>
<div class="line">      struct has_member_##test_name##_impl                                              \</div>
<div class="line">      {                                                                                 \</div>
<div class="line">        template &lt;class TT, class AA&gt;                                                   \</div>
<div class="line">        static <span class="keyword">auto</span> test(<span class="keywordtype">int</span>) -&gt; decltype( <a class="code" href="classcereal_1_1access.html#a7e4479612424135647241983ad094547">cereal::access::member_load_minimal</a>(         \</div>
<div class="line">              std::declval&lt;AA const &amp;&gt;(),                                               \</div>
<div class="line">              std::declval&lt;TT &amp;&gt;(), AnyConvert() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>());                   \</div>
<div class="line">        template &lt;class, class&gt; <span class="keyword">static</span> <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test(...);                                    \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> = std::is_same&lt;decltype(test&lt;T, A&gt;(0)), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value;    \</div>
<div class="line">      };                                                                                \</div>
<div class="line">      template &lt;class T, class A, class U&gt;                                              \</div>
<div class="line">      struct has_member_##test_name##_type_impl                                         \</div>
<div class="line">      {                                                                                 \</div>
<div class="line">        template &lt;class TT, class AA, class UU&gt;                                         \</div>
<div class="line">        static <span class="keyword">auto</span> test(<span class="keywordtype">int</span>) -&gt; decltype( <a class="code" href="classcereal_1_1access.html#a7e4479612424135647241983ad094547">cereal::access::member_load_minimal</a>(         \</div>
<div class="line">              std::declval&lt;AA const &amp;&gt;(),                                               \</div>
<div class="line">              std::declval&lt;TT &amp;&gt;(), NoConvertConstRef&lt;UU&gt;() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>());        \</div>
<div class="line">        template &lt;class, class, class&gt; <span class="keyword">static</span> <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test(...);                             \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> = std::is_same&lt;decltype(test&lt;T, A, U&gt;(0)), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value; \</div>
<div class="line">                                                                                        \</div>
<div class="line">      };                                                                                \</div>
<div class="line">    } <span class="comment">/* end namespace detail */</span></div>
<div class="ttc" id="aclasscereal_1_1access_html_a7e4479612424135647241983ad094547"><div class="ttname"><a href="classcereal_1_1access.html#a7e4479612424135647241983ad094547">cereal::access::member_load_minimal</a></div><div class="ttdeci">static auto member_load_minimal(Archive const &amp;ar, T &amp;t, U &amp;&amp;u) -&gt; decltype(t.CEREAL_LOAD_MINIMAL_FUNCTION_NAME(ar, std::forward&lt; U &gt;(u)))</div><div class="ttdef"><b>Definition:</b> access.hpp:269</div></div>
<div class="ttc" id="anamespacecereal_1_1traits_html_a32b99987a136bc56cb30707526c9ba2f"><div class="ttname"><a href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">cereal::traits::yes</a></div><div class="ttdeci">std::true_type yes</div><div class="ttdef"><b>Definition:</b> traits.hpp:49</div></div>
<div class="ttc" id="anamespacecereal_1_1traits_html_ad22419d99e8d081eef29f2f99e5cb54c"><div class="ttname"><a href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">cereal::traits::no</a></div><div class="ttdeci">std::false_type no</div><div class="ttdef"><b>Definition:</b> traits.hpp:50</div></div>
</div><!-- fragment -->
<p>Creates a test for whether a member load_minimal function exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper member function for the given archive.</p>
<p>Our strategy here is to first check if a function matching the signature more or less exists (allow anything like load_minimal(xxx) using AnyConvert, and then secondly enforce that it has the correct signature using NoConvertConstRef</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_name</td><td>The name to give the test (e.g. load_minimal or versioned_load_minimal) </td></tr>
    <tr><td class="paramname">versioned</td><td>Either blank or the macro CEREAL_MAKE_VERSIONED_TEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4497ffc80b9053f731b781d740b98af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4497ffc80b9053f731b781d740b98af2">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_TEST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">load_test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">load_test_prefix&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;                                                                                                \</div>
<div class="line">    struct has_member_##load_test_prefix##_minimal : std::integral_constant&lt;bool,                                              \</div>
<div class="line">      detail::has_member_##load_test_name##<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">_wrapper&lt;T, A, detail::has_member_##load_test_name##_impl&lt;T, A&gt;::value</a>&gt;<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>&gt; {};</div>
</div><!-- fragment -->
<p>Creates a test for whether a member load_minimal function exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper member function for the given archive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">load_test_name</td><td>The name to give the test (e.g. load_minimal or versioned_load_minimal) </td></tr>
    <tr><td class="paramname">load_test_prefix</td><td>The above parameter minus the trailing "_minimal" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a669b39fde8f86acef9e5b1470ceb0364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669b39fde8f86acef9e5b1470ceb0364">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_MEMBER_SAVE_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_MEMBER_SAVE_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a>                                                                                                                \</div>
<div class="line">    {                                                                                                                               \</div>
<div class="line">    template &lt;class T, class A&gt;                                                                                                     \</div>
<div class="line">    struct has_member_##test_name##_impl                                                                                            \</div>
<div class="line">      {                                                                                                                             \</div>
<div class="line">        template &lt;class TT, class AA&gt;                                                                                               \</div>
<div class="line">        static <span class="keyword">auto</span> test(<span class="keywordtype">int</span>) -&gt; decltype( <a class="code" href="classcereal_1_1access.html#a9ac38aa11b94a4178ec335aa5dc49fbb">cereal::access::member_save</a>( std::declval&lt;AA&amp;&gt;(),                                        \</div>
<div class="line">                                                                        std::declval&lt;TT const &amp;&gt;() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>());             \</div>
<div class="line">        template &lt;class, class&gt; <span class="keyword">static</span> <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test(...);                                                                                \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> = std::is_same&lt;decltype(test&lt;T, A&gt;(0)), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value;                                                \</div>
<div class="line">                                                                                                                                    \</div>
<div class="line">        template &lt;class TT, class AA&gt;                                                                                               \</div>
<div class="line">        static <span class="keyword">auto</span> test2(<span class="keywordtype">int</span>) -&gt; decltype( <a class="code" href="classcereal_1_1access.html#a9aee7c190fe592ab85e2ecef35645adf">cereal::access::member_save_non_const</a>(                                                  \</div>
<div class="line">                                              std::declval&lt;AA &amp;&gt;(),                                                                 \</div>
<div class="line">                                              std::declval&lt;<span class="keyword">typename</span> <a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">std::remove_const&lt;TT&gt;::type</a>&amp;&gt;() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>());            \</div>
<div class="line">        template &lt;class, class&gt; <span class="keyword">static</span> <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test2(...);                                                                               \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> not_const_type = std::is_same&lt;decltype(test2&lt;T, A&gt;(0)), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value;                                      \</div>
<div class="line">      };                                                                                                                            \</div>
<div class="line">    } <span class="comment">/* end namespace detail */</span></div>
<div class="ttc" id="aclasscereal_1_1access_html_a9ac38aa11b94a4178ec335aa5dc49fbb"><div class="ttname"><a href="classcereal_1_1access.html#a9ac38aa11b94a4178ec335aa5dc49fbb">cereal::access::member_save</a></div><div class="ttdeci">static auto member_save(Archive &amp;ar, T const &amp;t) -&gt; decltype(t.CEREAL_SAVE_FUNCTION_NAME(ar))</div><div class="ttdef"><b>Definition:</b> access.hpp:249</div></div>
<div class="ttc" id="aclasscereal_1_1access_html_a9aee7c190fe592ab85e2ecef35645adf"><div class="ttname"><a href="classcereal_1_1access.html#a9aee7c190fe592ab85e2ecef35645adf">cereal::access::member_save_non_const</a></div><div class="ttdeci">static auto member_save_non_const(Archive &amp;ar, T &amp;t) -&gt; decltype(t.CEREAL_SAVE_FUNCTION_NAME(ar))</div><div class="ttdef"><b>Definition:</b> access.hpp:253</div></div>
</div><!-- fragment -->
<p>Creates a test for whether a member save function exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper member function for the given archive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_name</td><td>The name to give the test (e.g. save or versioned_save) </td></tr>
    <tr><td class="paramname">versioned</td><td>Either blank or the macro CEREAL_MAKE_VERSIONED_TEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab60653db33c8898506326963f8a7211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab60653db33c8898506326963f8a7211">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_HELPERS_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_HELPERS_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a>                                                                                         \</div>
<div class="line">    {                                                                                                        \</div>
<div class="line">      template &lt;class T, class A, bool Valid&gt;                                                                \</div>
<div class="line">      struct get_member_##test_name##_type { <span class="keyword">using</span> <a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">type</a> = void; };                                           \</div>
<div class="line">                                                                                                             \</div>
<div class="line">      template &lt;class T, class A&gt;                                                                            \</div>
<div class="line">      struct get_member_##test_name##_type&lt;T, A, true&gt;                                                       \</div>
<div class="line">      {                                                                                                      \</div>
<div class="line">        using <a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">type</a> = decltype( <a class="code" href="classcereal_1_1access.html#aed7f0b5ff17ecf3090e43da940534bfb">cereal::access::member_save_minimal</a>( std::declval&lt;A const &amp;&gt;(),               \</div>
<div class="line">                                                                    std::declval&lt;T const &amp;&gt;() versioned ) ); \</div>
<div class="line">      };                                                                                                     \</div>
<div class="line">    } <span class="comment">/* end namespace detail */</span></div>
<div class="ttc" id="aclasscereal_1_1access_html_aed7f0b5ff17ecf3090e43da940534bfb"><div class="ttname"><a href="classcereal_1_1access.html#aed7f0b5ff17ecf3090e43da940534bfb">cereal::access::member_save_minimal</a></div><div class="ttdeci">static auto member_save_minimal(Archive const &amp;ar, T const &amp;t) -&gt; decltype(t.CEREAL_SAVE_MINIMAL_FUNCTION_NAME(ar))</div><div class="ttdef"><b>Definition:</b> access.hpp:261</div></div>
</div><!-- fragment -->
<p>Creates helpers for minimal save functions. </p>
<p>The get_member_*_type structs allow access to the return type of a save_minimal, assuming that the function actually exists. If the function does not exist, the type will be void.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_name</td><td>The name to give the test (e.g. save_minimal or versioned_save_minimal) </td></tr>
    <tr><td class="paramname">versioned</td><td>Either blank or the macro CEREAL_MAKE_VERSIONED_TEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d9d56e1b4254790186b1565796fdd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9d56e1b4254790186b1565796fdd35">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a>                                                                           \</div>
<div class="line">    {                                                                                          \</div>
<div class="line">      template &lt;class T, class A&gt;                                                              \</div>
<div class="line">      struct has_member_##test_name##_impl                                                     \</div>
<div class="line">      {                                                                                        \</div>
<div class="line">        template &lt;class TT, class AA&gt;                                                          \</div>
<div class="line">        static <span class="keyword">auto</span> test(<span class="keywordtype">int</span>) -&gt; decltype( <a class="code" href="classcereal_1_1access.html#aed7f0b5ff17ecf3090e43da940534bfb">cereal::access::member_save_minimal</a>(                \</div>
<div class="line">              std::declval&lt;AA const &amp;&gt;(),                                                      \</div>
<div class="line">              std::declval&lt;TT const &amp;&gt;() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>());                                  \</div>
<div class="line">        template &lt;class, class&gt; <span class="keyword">static</span> <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test(...);                                           \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> = std::is_same&lt;decltype(test&lt;T, A&gt;(0)), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value;           \</div>
<div class="line">                                                                                               \</div>
<div class="line">        template &lt;class TT, class AA&gt;                                                          \</div>
<div class="line">        static <span class="keyword">auto</span> test2(<span class="keywordtype">int</span>) -&gt; decltype( <a class="code" href="classcereal_1_1access.html#a90b1fcd3d987d395e4fc309a75ae007e">cereal::access::member_save_minimal_non_const</a>(     \</div>
<div class="line">              std::declval&lt;AA const &amp;&gt;(),                                                      \</div>
<div class="line">              std::declval&lt;<span class="keyword">typename</span> <a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">std::remove_const&lt;TT&gt;::type</a>&amp;&gt;() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>());       \</div>
<div class="line">        template &lt;class, class&gt; <span class="keyword">static</span> <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test2(...);                                          \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> not_const_type = std::is_same&lt;decltype(test2&lt;T, A&gt;(0)), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value; \</div>
<div class="line">                                                                                               \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> valid = <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> || !not_const_type;                                    \</div>
<div class="line">      };                                                                                       \</div>
<div class="line">    } <span class="comment">/* end namespace detail */</span></div>
<div class="ttc" id="aclasscereal_1_1access_html_a90b1fcd3d987d395e4fc309a75ae007e"><div class="ttname"><a href="classcereal_1_1access.html#a90b1fcd3d987d395e4fc309a75ae007e">cereal::access::member_save_minimal_non_const</a></div><div class="ttdeci">static auto member_save_minimal_non_const(Archive const &amp;ar, T &amp;t) -&gt; decltype(t.CEREAL_SAVE_MINIMAL_FUNCTION_NAME(ar))</div><div class="ttdef"><b>Definition:</b> access.hpp:265</div></div>
</div><!-- fragment -->
<p>Creates implementation details for whether a member save_minimal function exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper member function for the given archive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_name</td><td>The name to give the test (e.g. save_minimal or versioned_save_minimal) </td></tr>
    <tr><td class="paramname">versioned</td><td>Either blank or the macro CEREAL_MAKE_VERSIONED_TEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33f583ea76bb88656995fa4d5d5e9ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f583ea76bb88656995fa4d5d5e9ade">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_TEST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;                                                                                      \</div>
<div class="line">    struct has_member_##test_name : <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">std::integral_constant&lt;bool, detail::has_member_##test_name##_impl&lt;T, A&gt;::value</a>&gt; \</div>
<div class="line">    {                                                                                                                \</div>
<div class="line">      using check = <span class="keyword">typename</span> detail::has_member_##test_name##_impl&lt;T, A&gt;;                                            \</div>
<div class="line">      static_assert( check::valid,                                                                                   \</div>
<div class="line">        <span class="stringliteral">&quot;cereal detected a non-const member &quot;</span> #test_name <span class="stringliteral">&quot;. \n &quot;</span>                                                     \</div>
<div class="line">        #test_name <span class="stringliteral">&quot; member functions must always be const&quot;</span> );                                                       \</div>
<div class="line">                                                                                                                     \</div>
<div class="line">      using <a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">type</a> = <span class="keyword">typename</span> detail::get_member_##test_name##<a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">_type&lt;T, A, check::value&gt;::type</a>;                         \</div>
<div class="line">      static_assert( (<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">check::value</a> &amp;&amp; <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">is_minimal_type&lt;type&gt;::value</a>) || !<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">check::value</a>,                                \</div>
<div class="line">        <span class="stringliteral">&quot;cereal detected a member &quot;</span> #test_name <span class="stringliteral">&quot; with an invalid return type. \n &quot;</span>                                   \</div>
<div class="line">        <span class="stringliteral">&quot;return type must be arithmetic or string&quot;</span> );                                                                \</div>
<div class="line">    };</div>
</div><!-- fragment -->
<p>Creates a test for whether a member save_minimal function exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper member function for the given archive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_name</td><td>The name to give the test (e.g. save_minimal or versioned_save_minimal) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2fc70d51b619b785c0741568f2012ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fc70d51b619b785c0741568f2012ba">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_MEMBER_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_MEMBER_TEST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a>                                                                                                                    \</div>
<div class="line">    {                                                                                                                                   \</div>
<div class="line">      template &lt;class T, class A&gt;                                                                                                       \</div>
<div class="line">      struct has_member_##name##_##versioned##_impl                                                                                     \</div>
<div class="line">      {                                                                                                                                 \</div>
<div class="line">        template &lt;class TT, class AA&gt;                                                                                                   \</div>
<div class="line">        static <span class="keyword">auto</span> test(<span class="keywordtype">int</span>) -&gt; decltype( cereal::access::member_##name( std::declval&lt;AA&amp;&gt;(), std::declval&lt;TT&amp;&gt;() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>()); \</div>
<div class="line">        template &lt;class, class&gt;                                                                                                         \</div>
<div class="line">        static <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test(...);                                                                                                            \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> = std::is_same&lt;decltype(test&lt;T, A&gt;(0)), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value;                                                    \</div>
<div class="line">      };                                                                                                                                \</div>
<div class="line">    } <span class="comment">/* end namespace detail */</span>                                                                                                        \</div>
<div class="line">    template &lt;class T, class A&gt;                                                                                                         \</div>
<div class="line">    struct has_member_##test_name : <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">std::integral_constant&lt;bool, detail::has_member_##name##_##versioned##_impl&lt;T, A&gt;::value</a>&gt; {}</div>
</div><!-- fragment -->
<p>Creates a test for whether a non const member function exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper member function for the given archive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the function to test for (e.g. serialize, load, save) </td></tr>
    <tr><td class="paramname">test_name</td><td>The name to give the test for the function being tested for (e.g. serialize, versioned_serialize) </td></tr>
    <tr><td class="paramname">versioned</td><td>Either blank or the macro CEREAL_MAKE_VERSIONED_TEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65a75d150c050c8a44ab1d9d2b85bba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a75d150c050c8a44ab1d9d2b85bba6">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_NON_MEMBER_LOAD_AND_CONSTRUCT_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_NON_MEMBER_LOAD_AND_CONSTRUCT_TEST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a>                                                                                                            \</div>
<div class="line">    {                                                                                                                           \</div>
<div class="line">      template &lt;class T, class A&gt;                                                                                               \</div>
<div class="line">      struct has_non_member_##test_name##_impl                                                                                  \</div>
<div class="line">      {                                                                                                                         \</div>
<div class="line">        template &lt;class TT, class AA&gt;                                                                                           \</div>
<div class="line">        static <span class="keyword">auto</span> test(<span class="keywordtype">int</span>) -&gt; decltype( LoadAndConstruct&lt;TT&gt;::load_and_construct(                                            \</div>
<div class="line">                                           std::declval&lt;AA&amp;&gt;(), std::declval&lt; ::<a class="code" href="classcereal_1_1construct.html">cereal::construct&lt;TT&gt;</a>&amp;&gt;() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>());  \</div>
<div class="line">        template &lt;class, class&gt;                                                                                                 \</div>
<div class="line">        static <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test( ... );                                                                                                  \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> = std::is_same&lt;decltype( test&lt;T, A&gt;( 0 ) ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value;                                        \</div>
<div class="line">      };                                                                                                                        \</div>
<div class="line">    } <span class="comment">/* end namespace detail */</span>                                                                                                \</div>
<div class="line">    template &lt;class T, class A&gt;                                                                                                 \</div>
<div class="line">    struct has_non_member_##test_name :                                                                                         <a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">\</a></div>
<div class="line"><a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">      std::integral_constant&lt;bool, detail::has_non_member_##test_name##_impl&lt;typename std::remove_const&lt;T&gt;::type</a>, A&gt;<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>&gt; {};</div>
<div class="ttc" id="aclasscereal_1_1construct_html"><div class="ttname"><a href="classcereal_1_1construct.html">cereal::construct</a></div><div class="ttdoc">Used to construct types with no default constructor.</div><div class="ttdef"><b>Definition:</b> access.hpp:165</div></div>
</div><!-- fragment -->
<p>Creates a test for whether a non-member load_and_construct specialization exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper non-member function for the given archive. </p>

</div>
</div>
<a id="a99298ef5f4678723f35d175291eb5770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99298ef5f4678723f35d175291eb5770">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_NON_MEMBER_LOAD_MINIMAL_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_NON_MEMBER_LOAD_MINIMAL_TEST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">save_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a test for whether a non-member load_minimal function exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper member function for the given archive.</p>
<p>See notes from member load_minimal implementation.</p>
<p>Note that there should be an additional const check on load_minimal after the valid check, but this currently interferes with many valid uses of minimal serialization. It has been removed (see #565 on github) and previously was:</p>
<div class="fragment"><div class="line">static_assert( check::const_valid || !check::exists,</div>
<div class="line">    <span class="stringliteral">&quot;cereal detected an invalid serialization type parameter in non-member &quot;</span> #test_name <span class="stringliteral">&quot;.  &quot;</span></div>
<div class="line">    #test_name <span class="stringliteral">&quot; non-member functions must accept their serialization type by non-const reference&quot;</span> );</div>
</div><!-- fragment --><p>See #132, #436, #263, and #565 on <a href="https://github.com/USCiLab/cereal">https://github.com/USCiLab/cereal</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_name</td><td>The name to give the test (e.g. load_minimal or versioned_load_minimal) </td></tr>
    <tr><td class="paramname">save_name</td><td>The corresponding name the save test would have (e.g. save_minimal or versioned_save_minimal) </td></tr>
    <tr><td class="paramname">versioned</td><td>Either blank or the macro CEREAL_MAKE_VERSIONED_TEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7eb2173790b30144a419f33afcd2710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7eb2173790b30144a419f33afcd2710">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_NON_MEMBER_SAVE_MINIMAL_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_NON_MEMBER_SAVE_MINIMAL_TEST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a test for whether a non-member save_minimal function exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper member function for the given archive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_name</td><td>The name to give the test (e.g. save_minimal or versioned_save_minimal) </td></tr>
    <tr><td class="paramname">versioned</td><td>Either blank or the macro CEREAL_MAKE_VERSIONED_TEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5be76cc82813adfc110f793e37636fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be76cc82813adfc110f793e37636fb1">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_NON_MEMBER_SAVE_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_NON_MEMBER_SAVE_TEST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a>                                                                                                         \</div>
<div class="line">    {                                                                                                                        \</div>
<div class="line">      template &lt;class T, class A&gt;                                                                                            \</div>
<div class="line">      struct has_non_member_##test_name##_impl                                                                               \</div>
<div class="line">      {                                                                                                                      \</div>
<div class="line">        template &lt;class TT, class AA&gt;                                                                                        \</div>
<div class="line">        static <span class="keyword">auto</span> test(<span class="keywordtype">int</span>) -&gt; decltype( <a class="code" href="macros_8hpp.html#a85b7884671ac5a804b66ec7c34d0ca71">CEREAL_SAVE_FUNCTION_NAME</a>(                                                        \</div>
<div class="line">                                              std::declval&lt;AA&amp;&gt;(),                                                           \</div>
<div class="line">                                              std::declval&lt;TT const &amp;&gt;() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>());                                \</div>
<div class="line">        template &lt;class, class&gt; <span class="keyword">static</span> <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test(...);                                                                         \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> = std::is_same&lt;decltype(test&lt;T, A&gt;(0)), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value;                                         \</div>
<div class="line">                                                                                                                             \</div>
<div class="line">        template &lt;class TT, class AA&gt;                                                                                        \</div>
<div class="line">        static <span class="keyword">auto</span> test2(<span class="keywordtype">int</span>) -&gt; decltype( <a class="code" href="macros_8hpp.html#a85b7884671ac5a804b66ec7c34d0ca71">CEREAL_SAVE_FUNCTION_NAME</a>(                                                       \</div>
<div class="line">                                              std::declval&lt;AA &amp;&gt;(),                                                          \</div>
<div class="line">                                              std::declval&lt;<span class="keyword">typename</span> <a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">std::remove_const&lt;TT&gt;::type</a>&amp;&gt;() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>());     \</div>
<div class="line">        template &lt;class, class&gt; <span class="keyword">static</span> <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test2(...);                                                                        \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> not_const_type = std::is_same&lt;decltype(test2&lt;T, A&gt;(0)), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value;                               \</div>
<div class="line">      };                                                                                                                     \</div>
<div class="line">    } <span class="comment">/* end namespace detail */</span>                                                                                             \</div>
<div class="line">                                                                                                                             \</div>
<div class="line">    template &lt;class T, class A&gt;                                                                                              \</div>
<div class="line">    struct has_non_member_##test_name : <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">std::integral_constant&lt;bool, detail::has_non_member_##test_name##_impl&lt;T, A&gt;::value</a>&gt; \</div>
<div class="line">    {                                                                                                                        \</div>
<div class="line">      using check = <span class="keyword">typename</span> detail::has_non_member_##test_name##_impl&lt;T, A&gt;;                                                \</div>
<div class="line">      static_assert( <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">check::value</a> || !check::not_const_type,                                                                 \</div>
<div class="line">        <span class="stringliteral">&quot;cereal detected a non-const type parameter in non-member &quot;</span> #test_name <span class="stringliteral">&quot;. \n &quot;</span>                                       \</div>
<div class="line">        #test_name <span class="stringliteral">&quot; non-member functions must always pass their types as const&quot;</span> );                                          \</div>
<div class="line">    };</div>
<div class="ttc" id="amacros_8hpp_html_a85b7884671ac5a804b66ec7c34d0ca71"><div class="ttname"><a href="macros_8hpp.html#a85b7884671ac5a804b66ec7c34d0ca71">CEREAL_SAVE_FUNCTION_NAME</a></div><div class="ttdeci">#define CEREAL_SAVE_FUNCTION_NAME</div><div class="ttdoc">The serialization (save) function name to search for.</div><div class="ttdef"><b>Definition:</b> macros.hpp:92</div></div>
</div><!-- fragment -->
<p>Creates a test for whether a non-member save function exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper non-member function for the given archive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test_name</td><td>The name to give the test (e.g. save or versioned_save) </td></tr>
    <tr><td class="paramname">versioned</td><td>Either blank or the macro CEREAL_MAKE_VERSIONED_TEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af31f4783772a7f6a3048a793090715cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31f4783772a7f6a3048a793090715cf">&#9670;&nbsp;</a></span>CEREAL_MAKE_HAS_NON_MEMBER_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_HAS_NON_MEMBER_TEST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a>                                                                                                            \</div>
<div class="line">    {                                                                                                                           \</div>
<div class="line">      template &lt;class T, class A&gt;                                                                                               \</div>
<div class="line">      struct has_non_member_##test_name##_impl                                                                                  \</div>
<div class="line">      {                                                                                                                         \</div>
<div class="line">        template &lt;class TT, class AA&gt;                                                                                           \</div>
<div class="line">        static <span class="keyword">auto</span> test(<span class="keywordtype">int</span>) -&gt; decltype( func( std::declval&lt;AA&amp;&gt;(), std::declval&lt;TT&amp;&gt;() versioned ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>());                  \</div>
<div class="line">        template &lt;class, class&gt;                                                                                                 \</div>
<div class="line">        static <a class="code" href="namespacecereal_1_1traits.html#ad22419d99e8d081eef29f2f99e5cb54c">no</a> test( ... );                                                                                                  \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a> = std::is_same&lt;decltype( test&lt;T, A&gt;( 0 ) ), <a class="code" href="namespacecereal_1_1traits.html#a32b99987a136bc56cb30707526c9ba2f">yes</a>&gt;::value;                                        \</div>
<div class="line">      };                                                                                                                        \</div>
<div class="line">    } <span class="comment">/* end namespace detail */</span>                                                                                                \</div>
<div class="line">    template &lt;class T, class A&gt;                                                                                                 \</div>
<div class="line">    struct has_non_member_##test_name : <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">std::integral_constant&lt;bool, detail::has_non_member_##test_name##_impl&lt;T, A&gt;::value</a>&gt; {}</div>
</div><!-- fragment -->
<p>Creates a test for whether a non const non-member function exists. </p>
<p>This creates a class derived from std::integral_constant that will be true if the type has the proper non-member function for the given archive. </p>

</div>
</div>
<a id="af566f627f0de18c31e2bbb21a01cce70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af566f627f0de18c31e2bbb21a01cce70">&#9670;&nbsp;</a></span>CEREAL_MAKE_IS_SPECIALIZED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_IS_SPECIALIZED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">spec_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;                                                             \</div>
<div class="line">    struct is_specialized_##name : std::integral_constant&lt;bool,                             <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">\</a></div>
<div class="line"><a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">      is_specialized&lt;T, A&gt;::value</a> &amp;&amp; detail::is_specialized_##<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">spec_name&lt;T, A&gt;::value</a>&gt;       \</div>
<div class="line">    { <a class="code" href="traits_8hpp.html#a7e6519141d71272bbe5db25d01d175ad">CEREAL_MAKE_IS_SPECIALIZED_ASSERT</a>(name, versioned_name, name, spec_name); };          \</div>
<div class="line">    template &lt;class T, class A&gt;                                                             \</div>
<div class="line">    struct is_specialized_##versioned_name : std::integral_constant&lt;bool,                   <a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">\</a></div>
<div class="line"><a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">      is_specialized&lt;T, A&gt;::value</a> &amp;&amp; detail::is_specialized_##<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">spec_name&lt;T, A&gt;::value</a>&gt;       \</div>
<div class="line">    { <a class="code" href="traits_8hpp.html#a7e6519141d71272bbe5db25d01d175ad">CEREAL_MAKE_IS_SPECIALIZED_ASSERT</a>(name, versioned_name, versioned_name, spec_name); }</div>
<div class="ttc" id="atraits_8hpp_html_a7e6519141d71272bbe5db25d01d175ad"><div class="ttname"><a href="traits_8hpp.html#a7e6519141d71272bbe5db25d01d175ad">CEREAL_MAKE_IS_SPECIALIZED_ASSERT</a></div><div class="ttdeci">#define CEREAL_MAKE_IS_SPECIALIZED_ASSERT(name, versioned_name, print_name, spec_name)</div><div class="ttdoc">Create the static assertion for some specialization.</div><div class="ttdef"><b>Definition:</b> traits.hpp:1028</div></div>
</div><!-- fragment -->
<p>Generates a test for specialization for versioned and unversioned functions. </p>
<p>This creates checks that can be queried to see if a given type of serialization function has been specialized for this type </p>

</div>
</div>
<a id="a7e6519141d71272bbe5db25d01d175ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6519141d71272bbe5db25d01d175ad">&#9670;&nbsp;</a></span>CEREAL_MAKE_IS_SPECIALIZED_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_IS_SPECIALIZED_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">versioned_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">print_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">spec_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    static_assert( (<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">is_specialized&lt;T, A&gt;::value</a> &amp;&amp; detail::is_specialized_##<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">spec_name&lt;T, A&gt;::value</a> &amp;&amp;           \</div>
<div class="line">                   (has_##<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">name&lt;T, A&gt;::value</a> || has_##<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">versioned_name&lt;T, A&gt;::value</a>))                              \</div>
<div class="line">                   || !(<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">is_specialized&lt;T, A&gt;::value</a> &amp;&amp; detail::is_specialized_##<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">spec_name&lt;T, A&gt;::value</a>),        \</div>
<div class="line">                   <span class="stringliteral">&quot;cereal detected &quot;</span> #print_name <span class="stringliteral">&quot; specialization but no &quot;</span> #print_name <span class="stringliteral">&quot; serialize function&quot;</span> )</div>
</div><!-- fragment -->
<p>Create the static assertion for some specialization. </p>
<p>This assertion will fail if the type is indeed specialized and does not have the appropriate type of serialization functions </p>

</div>
</div>
<a id="a33ec65e257576ae208d6a71cf01c4258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ec65e257576ae208d6a71cf01c4258">&#9670;&nbsp;</a></span>CEREAL_MAKE_IS_SPECIALIZED_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_IS_SPECIALIZED_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;                                                            \</div>
<div class="line">      struct is_specialized_##name : std::integral_constant&lt;bool,                            \</div>
<div class="line">        !std::is_base_of&lt;std::false_type, specialize&lt;A, T, specialization::name&gt;&gt;<a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>&gt; {}</div>
</div><!-- fragment -->
<p>Create a test for a cereal::specialization entry. </p>

</div>
</div>
<a id="a8638d8b3af51cf4f6bed0ed2dae54928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8638d8b3af51cf4f6bed0ed2dae54928">&#9670;&nbsp;</a></span>CEREAL_MAKE_VERSIONED_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_MAKE_VERSIONED_TEST&#160;&#160;&#160;,0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to convert a MAKE_HAS_XXX macro into a versioned variant. </p>

</div>
</div>
<a id="a039bc7d4a3e8994d3fd7eedf5cae1666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039bc7d4a3e8994d3fd7eedf5cae1666">&#9670;&nbsp;</a></span>CEREAL_SETUP_ARCHIVE_TRAITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CEREAL_SETUP_ARCHIVE_TRAITS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">InputArchive, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OutputArchive&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">namespace </span><a class="code" href="namespacecereal.html">cereal</a> { <span class="keyword">namespace </span>traits { <span class="keyword">namespace </span><a class="code" href="namespacedetail.html">detail</a> {          \</div>
<div class="line">      template &lt;&gt; <span class="keyword">struct </span>get_output_from_input&lt;InputArchive&gt;          \</div>
<div class="line">      { <span class="keyword">using</span> <a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">type</a> = OutputArchive; };                                \</div>
<div class="line">      template &lt;&gt; <span class="keyword">struct </span>get_input_from_output&lt;OutputArchive&gt;         \</div>
<div class="line">      { <span class="keyword">using</span> <a class="code" href="namespacecereal_1_1bitset__detail.html#a4f5825a3267dd05e798bed76cf7e29cc">type</a> = InputArchive; }; } } } <span class="comment">/* end namespaces */</span></div>
<div class="ttc" id="anamespacecereal_html"><div class="ttname"><a href="namespacecereal.html">cereal</a></div><div class="ttdoc">in certain simple scenarios. They should probably not be used if maximizing performance is the main o...</div><div class="ttdef"><b>Definition:</b> access.hpp:42</div></div>
</div><!-- fragment -->
<p>Sets up traits that relate an input archive to an output archive. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a07719740a7cec6692b44244201a92603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07719740a7cec6692b44244201a92603">&#9670;&nbsp;</a></span>DisableIf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ... Conditions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="traits_8hpp.html#a07719740a7cec6692b44244201a92603">DisableIf</a> =  typename detail::DisableIfHelper&lt;Conditions...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a way to disable a function if conditions are met. </p>
<p>This is intended to be used in a near identical fashion to std::enable_if while being significantly easier to read at the cost of not allowing for as complicated of a condition.</p>
<p>This will compile (allow the function) if every condition evaluates to false. This should be used with SFINAE to ensure that at least one other candidate function works when one fails due to a DisableIf.</p>
<p>This should be used as the las template parameter to a function as an unnamed parameter with a default value of cereal::traits::sfinae:</p>
<div class="fragment"><div class="line"><span class="comment">// using by making the last template argument variadic</span></div>
<div class="line"><a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">template &lt;class T, DisableIf&lt;std::is_same&lt;T, bool&gt;::value</a>&gt; = <a class="code" href="traits_8hpp.html#ac1c99b1883f356bf4cbfda710ee68e91">sfinae</a>&gt;</div>
<div class="line"><span class="keywordtype">void</span> func(T t );</div>
<div class="ttc" id="atraits_8hpp_html_ac1c99b1883f356bf4cbfda710ee68e91"><div class="ttname"><a href="traits_8hpp.html#ac1c99b1883f356bf4cbfda710ee68e91">sfinae</a></div><div class="ttdeci">static const detail::sfinae sfinae</div><div class="ttdoc">Used as the default value for EnableIf and DisableIf template parameters.</div><div class="ttdef"><b>Definition:</b> traits.hpp:88</div></div>
</div><!-- fragment --><p>This is often used in conjunction with EnableIf to form an enable/disable pair of overloads.</p>
<p>Note that this performs a logical AND of all conditions, so you will need to construct more complicated requirements with this fact in mind. If all conditions hold, the function will be disabled.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Conditions</td><td>The conditions which will be logically ANDed to disable the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42e5f793ba5a1b3d2fd674d7334b12bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e5f793ba5a1b3d2fd674d7334b12bd">&#9670;&nbsp;</a></span>EnableIf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ... Conditions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="traits_8hpp.html#a42e5f793ba5a1b3d2fd674d7334b12bd">EnableIf</a> =  typename detail::EnableIfHelper&lt;Conditions...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a way to enable a function if conditions are met. </p>
<p>This is intended to be used in a near identical fashion to std::enable_if while being significantly easier to read at the cost of not allowing for as complicated of a condition.</p>
<p>This will compile (allow the function) if every condition evaluates to true. at compile time. This should be used with SFINAE to ensure that at least one other candidate function works when one fails due to an EnableIf.</p>
<p>This should be used as the las template parameter to a function as an unnamed parameter with a default value of cereal::traits::sfinae:</p>
<div class="fragment"><div class="line"><span class="comment">// using by making the last template argument variadic</span></div>
<div class="line"><a class="code" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">template &lt;class T, EnableIf&lt;std::is_same&lt;T, bool&gt;::value</a>&gt; = <a class="code" href="traits_8hpp.html#ac1c99b1883f356bf4cbfda710ee68e91">sfinae</a>&gt;</div>
<div class="line"><span class="keywordtype">void</span> func(T t );</div>
</div><!-- fragment --><p>Note that this performs a logical AND of all conditions, so you will need to construct more complicated requirements with this fact in mind.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Conditions</td><td>The conditions which will be logically ANDed to enable the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac1c99b1883f356bf4cbfda710ee68e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c99b1883f356bf4cbfda710ee68e91">&#9670;&nbsp;</a></span>sfinae</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const detail::sfinae sfinae = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used as the default value for EnableIf and DisableIf template parameters. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>NDDEM in the browser</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
            #N_tag {
                color: white;
                padding: 24px;
                font: 48px Montserrat;
                /* font-weight: bold; */
                position:absolute;
            }
        </style>
	</head>
	<body>
        <script async type="text/javascript" src="../bin/DEMND.js"></script>

		<script type="module">

			import * as THREE from './js/three.module.js';
			import { OrbitControls } from './js/OrbitControls.js';
            // import { NDDEMPhysics } from './js/NDDEMPhysics.js';
			import Stats from './js/stats.module.js';
            import { GUI } from './js/dat.gui.module.js';

			let camera, scene, renderer, stats;
			let physics, position;
            let gui;
			let boxes, spheres;
            let floor, roof, left, right, front, back;
            let S;
            let NDDEMLib;
            let pointer;
            let frameRate = 60;

            var radius = 0.5;
            var L;
            const thickness = radius;

            var params = {
                dimensions: 3,
                L: 3, //system size
                N: 200,
                packing_fraction: 0.5,
                shear_strain: 0,
                // gravity: 1,
                paused: false,
            }
            params.back = params.L;
            params.front = -params.L;

            // update_L();
            //
            // function update_L() {
            //     var L = params.N*4./3.*Math.PI*Math.pow(radius,3);
            //     L = Math.pow(solid_volume/params.packing_fraction,1./3.)
            // }

            var quality = 5;

			init();

			async function init() {

				physics = await NDDEMPhysics();
                // physics.main(params.dimensions, params.N, inputfile)
				position = new THREE.Vector3();

				//

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( - 10*params.L, 2*params.L, 0 );
                camera.up.set(0, 0, 1);
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x666666 );

                // const axesHelper = new THREE.AxesHelper( 5 );
                // scene.add( axesHelper );

				const hemiLight = new THREE.HemisphereLight();
				hemiLight.intensity = 0.35;
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight();
				dirLight.position.set( 5, 5, 5 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.zoom = 2;
				scene.add( dirLight );

                const wall_geometry = new THREE.BoxGeometry( params.L*2 + thickness*2, thickness, params.L*2 + thickness*2 );
                const wall_material = new THREE.MeshLambertMaterial();
                wall_material.wireframe = true;
                // const wall_material = new THREE.ShadowMaterial( )

				floor = new THREE.Mesh( wall_geometry, wall_material );
				floor.position.y = - params.L - thickness/2.;
				// floor.receiveShadow = true;
				scene.add( floor );
				// physics.addMesh( floor );

                roof = new THREE.Mesh( wall_geometry, wall_material );
                roof.position.y = params.L + thickness/2.;
                // top.receiveShadow = true;
                scene.add( roof );
                // physics.addMesh( roof );

                left = new THREE.Mesh( wall_geometry, wall_material );
                left.rotation.x = Math.PI/2.;
				left.position.z = - params.L - thickness/2.;
				// left.receiveShadow = true;
				scene.add( left );
				// physics.addMesh( left );

                right = new THREE.Mesh( wall_geometry, wall_material );
                right.rotation.x = Math.PI/2.;
				right.position.z = params.L + thickness/2.;
				// right.receiveShadow = true;
				scene.add( right );
				// physics.addMesh( right );

                back = new THREE.Mesh( wall_geometry, wall_material );
                back.rotation.z = Math.PI/2.;
                back.position.x = params.L + thickness/2.;
                // back.receiveShadow = true;
                scene.add( back );
                // physics.addMesh( back );

                front = new THREE.Mesh( wall_geometry, wall_material );
                front.rotation.z = Math.PI/2.;
                front.position.x = -params.L - thickness/2.;
                // front.receiveShadow = true;
                scene.add( front );
                // physics.addMesh( front );

				add_spheres();

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.outputEncoding = THREE.sRGBEncoding;
				document.body.appendChild( renderer.domElement );

				// stats = new Stats();
				// document.body.appendChild( stats.dom );

                // gui
				gui = new GUI();

				gui.width = 300;

				gui.domElement.style.userSelect = 'none';

				// const fl = gui.addFolder( 'Intensity' );

				gui.add( params, 'packing_fraction', 0, 1, 0.01 )
					.name( 'Initial density' ).listen()
					.onChange( function () { refresh_simulation(); } );
                gui.add( params, 'back', 0,10, 0.01)
                    .name( 'Back wall').listen()
                    .onChange( function () { update_walls(); } );
                gui.add( params, 'front', -10,0, 0.01)
                    .name( 'Front wall').listen()
                    .onChange( function () { update_walls(); } );
                // gui.add( params, 'shear_strain', 0, 1, 0.01 )
                    // .name( 'Shear strain' ).listen()
                    // .onChange( function () { update_walls(); } );
                gui.add ( params, 'paused').listen();
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.y = 0.5;
				controls.update();

				animate();
			}

            function update_walls() {
                var cur = S.getBoundary(0);
                S.setBoundary(0, [params.front,params.back,cur[2]]) ; // Set location of the bottom wall in dimension y to 0.1
                back.position.x = params.back;
                front.position.x = params.front;
                // console.log(S.getBoundary(0))
                // console.log(S.getBoundary(1))
                // console.log(S.getBoundary(2))
            }

			function animate() {

				requestAnimationFrame( animate );
                move_spheres();

                if ( !params.paused ) {
                    S.step_forward(100);
                }
                // console.log(window.x)

				//

				// let index = Math.floor( Math.random() * boxes.count );

				// position.set( 0, Math.random() + 1, 0 );
				// physics.setMeshPosition( boxes, position, index );

				//

				// index = Math.floor( Math.random() * spheres.count );

				// position.set( 0, Math.random() + 1, 0 );
				// physics.setMeshPosition( spheres, position, index );

				renderer.render( scene, camera );

				if ( stats !== undefined ) { stats.update(); }

			}
            function refresh_simulation() {
                // update_L();
                // console.log(L)
                var range = 0.8*(L/2 - radius);
                for ( let i = 0; i < params.N; i ++ ) {
                    position.set( range*(2*Math.random() - 1), range*(2*Math.random() - 1), range*(2*Math.random() - 1) );
    				physics.setMeshPosition( spheres, position, i );
                }
                position.set( 0, - L/2 - thickness/2., 0 );
                // physics.setMeshPosition( floor, position );

                floor.position.y = - L/2 - thickness/2.;
                roof.position.y = L/2 + thickness/2.;
                left.position.z = - L/2 - thickness/2.;
                right.position.z = L/2 + thickness/2.;
                back.position.x = L/2 + thickness/2.;
                front.position.x = -L/2 - thickness/2.;
                camera.position.set( - 3*L, 0, 0 );

            }

            function remove_spheres() {
                physics.removeMesh( );
            }

            function add_spheres() {
                const material = new THREE.MeshLambertMaterial();

                const matrix = new THREE.Matrix4();
                const color = new THREE.Color();

                const geometrySphere = new THREE.SphereGeometry( radius, Math.pow(2,quality), Math.pow(2,quality) );
                spheres = new THREE.InstancedMesh( geometrySphere, material, params.N );
                spheres.castShadow = true;
                spheres.receiveShadow = true;
                scene.add( spheres );

                // let x = NDDEMLib.HEAPF64.subarray(pointer, pointer + params.dimensions*params.N);
                var range = 0.8*(L/2 - radius);
                for ( let i = 0; i < params.N; i ++ ) {
                    // matrix.setPosition( x[0 + i*3], x[1 + i*3], x[2 + i*3] );
                    spheres.setMatrixAt( i, matrix );
                    spheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );

                }

                // physics.addMesh( spheres, 1 );
            }

            function move_spheres() {
                var x = S.getX();
                for ( let i = 0; i < params.N; i ++ ) {
                    const matrix = new THREE.Matrix4();
                    // console.log(x[i])
                    matrix.setPosition( x[i][0], x[i][1], x[i][2] );
                    spheres.setMatrixAt( i, matrix );
                }
                spheres.instanceMatrix.needsUpdate = true;
                // console.log(x)
                // physics.addMesh( spheres, 1 );
            }

            async function NDDEMPhysics() {

            	if ( 'DEMND' in window === false ) {

            		console.error( 'NDDEMPhysics: Couldn\'t find DEMND.js' );
            		return;

            	}

            	NDDEMLib = await DEMND(); // eslint-disable-line no-undef
                const Dimensions = 3;


                S = await new NDDEMLib.Simulation (params.N);
                S.interpret_command("dimensions 3 " + String(params.N));
                S.interpret_command("radius -1 0.5");
                S.interpret_command("mass -1 1");
                S.interpret_command("auto rho");
                S.interpret_command("auto inertia");

                S.interpret_command("boundary 0 WALL -"+String(params.L)+" "+String(params.L));
                S.interpret_command("boundary 1 WALL -"+String(params.L)+" "+String(params.L));
                S.interpret_command("boundary 2 WALL -"+String(params.L)+" "+String(params.L));
                // S.interpret_command("boundary 1 WALL 0 5");
                // S.interpret_command("boundary 2 WALL 0 3.4");
                S.interpret_command("auto location randomdrop");
                // S.interpret_command("gravity -"+String(params.gravity)+" 0 0");
                S.interpret_command("gravity -0.9 0.42 0")

                // NONE OF THESE DO ANYTHING YET
                S.interpret_command("set Kn 2e5");
                S.interpret_command("set Kt 8e4");
                S.interpret_command("set GammaN 75");
                S.interpret_command("set GammaT 75");
                S.interpret_command("set Mu 0.5");
                S.interpret_command("set T 150");
                S.interpret_command("set dt 0.0001");


            }

		</script>
	</body>
</html>

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>NDDEM in the browser</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="./css/main.css">
	</head>
	<body>
        <script async type="text/javascript" src="../bin/DEMND.js"></script>

		<script type="module">

			import * as THREE from './js/three.module.js';
			import { OrbitControls } from './js/OrbitControls.js';
            // import { NDDEMPhysics } from './js/NDDEMPhysics.js';
			import Stats from './js/stats.module.js';
            import { GUI } from './js/dat.gui.module.js';

			let camera, scene, renderer, stats;
			let physics, position;
            let gui;
			let boxes, spheres;
            let floor, roof, left, right, front, back;
            let S;
            let NDDEMLib;
            let pointer;
            let frameRate = 60;

            var radius = 0.5;
            var L;
            const thickness = radius;

            var params = {
                dimensions: 3,
                N: 50,
                packing_fraction: 0.5,
                volumetric_strain: 0,
                shear_strain: 0
            }

            update_L();

            function update_L() {
                var solid_volume = params.N*4./3.*Math.PI*Math.pow(radius,3);
                L = Math.pow(solid_volume/params.packing_fraction,1./3.)
            }

            var quality = 5;

			init();

			async function init() {

				physics = await NDDEMPhysics();
                // physics.main(params.dimensions, params.N, inputfile)
				position = new THREE.Vector3();

				//

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( - 30*L, 0, 0 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x666666 );

				const hemiLight = new THREE.HemisphereLight();
				hemiLight.intensity = 0.35;
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight();
				dirLight.position.set( 5, 5, 5 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.zoom = 2;
				scene.add( dirLight );

                const wall_geometry = new THREE.BoxGeometry( L + thickness*2, thickness, L + thickness*2 );
                const wall_material = new THREE.MeshLambertMaterial();
                wall_material.wireframe = true;
                // const wall_material = new THREE.ShadowMaterial( )

				floor = new THREE.Mesh( wall_geometry, wall_material );
				floor.position.y = - L/2 - thickness/2.;
				// floor.receiveShadow = true;
				scene.add( floor );
				// physics.addMesh( floor );

                roof = new THREE.Mesh( wall_geometry, wall_material );
                roof.position.y = L/2 + thickness/2.;
                // top.receiveShadow = true;
                scene.add( roof );
                // physics.addMesh( roof );

                left = new THREE.Mesh( wall_geometry, wall_material );
                left.rotation.x = Math.PI/2.;
				left.position.z = - L/2 - thickness/2.;
				// left.receiveShadow = true;
				scene.add( left );
				// physics.addMesh( left );

                right = new THREE.Mesh( wall_geometry, wall_material );
                right.rotation.x = Math.PI/2.;
				right.position.z = L/2 + thickness/2.;
				// right.receiveShadow = true;
				scene.add( right );
				// physics.addMesh( right );

                back = new THREE.Mesh( wall_geometry, wall_material );
                back.rotation.z = Math.PI/2.;
                back.position.x = L/2 + thickness/2.;
                // back.receiveShadow = true;
                scene.add( back );
                // physics.addMesh( back );

                front = new THREE.Mesh( wall_geometry, wall_material );
                front.rotation.z = Math.PI/2.;
                front.position.x = -L/2 - thickness/2.;
                // front.receiveShadow = true;
                scene.add( front );
                // physics.addMesh( front );

				add_spheres();

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.outputEncoding = THREE.sRGBEncoding;
				document.body.appendChild( renderer.domElement );

				// stats = new Stats();
				// document.body.appendChild( stats.dom );

                // gui
				gui = new GUI();

				gui.width = 300;

				gui.domElement.style.userSelect = 'none';

				// const fl = gui.addFolder( 'Intensity' );

				gui.add( params, 'packing_fraction', 0, 1, 0.01 )
					.name( 'Initial density' )
					.onChange( function () { refresh_simulation(); } );
                gui.add( params, 'volumetric_strain', 0, 1, 0.01 )
                    .name( 'Volumetric strain' )
                    .onChange( function () { update_walls(); } );
                gui.add( params, 'shear_strain', 0, 1, 0.01 )
                    .name( 'Shear strain' )
                    .onChange( function () { update_walls(); } );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.y = 0.5;
				controls.update();

				animate();


                setInterval(function(){
                    S.step_forward(1)
                //     var force = physics.getWallForce(2)
                //     // console.log(force)
                //     console.log(force.x(),force.y(),force.z())
                }, 200);


			}

			function animate() {

				requestAnimationFrame( animate );
                move_spheres();
                // console.log(window.x)

				//

				// let index = Math.floor( Math.random() * boxes.count );

				// position.set( 0, Math.random() + 1, 0 );
				// physics.setMeshPosition( boxes, position, index );

				//

				// index = Math.floor( Math.random() * spheres.count );

				// position.set( 0, Math.random() + 1, 0 );
				// physics.setMeshPosition( spheres, position, index );

				renderer.render( scene, camera );

				if ( stats !== undefined ) { stats.update(); }

			}
            function refresh_simulation() {
                update_L();
                console.log(L)
                var range = 0.8*(L/2 - radius);
                for ( let i = 0; i < params.N; i ++ ) {
                    position.set( range*(2*Math.random() - 1), range*(2*Math.random() - 1), range*(2*Math.random() - 1) );
    				physics.setMeshPosition( spheres, position, i );
                }
                position.set( 0, - L/2 - thickness/2., 0 );
                // physics.setMeshPosition( floor, position );

                floor.position.y = - L/2 - thickness/2.;
                roof.position.y = L/2 + thickness/2.;
                left.position.z = - L/2 - thickness/2.;
                right.position.z = L/2 + thickness/2.;
                back.position.x = L/2 + thickness/2.;
                front.position.x = -L/2 - thickness/2.;
                camera.position.set( - 3*L, 0, 0 );

            }

            function remove_spheres() {
                physics.removeMesh( );
            }

            function add_spheres() {
                const material = new THREE.MeshLambertMaterial();

                const matrix = new THREE.Matrix4();
                const color = new THREE.Color();

                const geometrySphere = new THREE.SphereGeometry( radius, Math.pow(2,quality), Math.pow(2,quality) );
                spheres = new THREE.InstancedMesh( geometrySphere, material, params.N );
                spheres.castShadow = true;
                spheres.receiveShadow = true;
                scene.add( spheres );

                // let x = NDDEMLib.HEAPF64.subarray(pointer, pointer + params.dimensions*params.N);
                var range = 0.8*(L/2 - radius);
                for ( let i = 0; i < params.N; i ++ ) {
                    // matrix.setPosition( x[0 + i*3], x[1 + i*3], x[2 + i*3] );
                    spheres.setMatrixAt( i, matrix );
                    spheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );

                }

                // physics.addMesh( spheres, 1 );
            }

            function move_spheres() {
                var x = S.getX();
                console.log(x[0][0])
                for ( let i = 0; i < params.N; i ++ ) {
                    const matrix = new THREE.Matrix4();
                    matrix.setPosition( x[i][0], x[i][1], x[i][2] );
                    spheres.setMatrixAt( i, matrix );
                }
                spheres.instanceMatrix.needsUpdate = true;
                // console.log(x)
                // physics.addMesh( spheres, 1 );
            }

            async function NDDEMPhysics() {

            	if ( 'DEMND' in window === false ) {

            		console.error( 'NDDEMPhysics: Couldn\'t find DEMND.js' );
            		return;

            	}

            	NDDEMLib = await DEMND(); // eslint-disable-line no-undef
                const Dimensions = 3;
                const Num_grains = 50;
            	const frameRate = 1000;

                S = await new NDDEMLib.Simulation (Num_grains);

                S.interpret_command("radius -1 0.5");
                S.interpret_command("mass -1 1");
                S.interpret_command("auto rho");
                S.interpret_command("auto inertia");

                S.interpret_command("boundary 0 WALL 0 20");
                S.interpret_command("boundary 1 PBC  0 4");
                S.interpret_command("boundary 2 PBC  0 4");
                S.interpret_command("auto location randomdrop");
                S.interpret_command("gravity -1 0 0");
                S.interpret_command("set Kn 2e3");
                S.interpret_command("set Kt 8e2");
                S.interpret_command("set GammaN 75");
                S.interpret_command("set GammaT 75");
                S.interpret_command("set Mu 0.5");
                S.interpret_command("set T 150");
                S.interpret_command("set dt 0.00001");

            }

		</script>
	</body>
</html>

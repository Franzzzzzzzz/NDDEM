<!DOCTYPE html>
<html lang="en">
	<head>
		<title>NDDEM in the browser</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
            #N_tag {
                color: white;
                padding: 24px;
                font: 48px Montserrat;
                /* font-weight: bold; */
                position:absolute;
            }
        </style>
	</head>
	<body>
        <script async type="text/javascript" src="../bin/DEMND.js"></script>

		<script type="module">

			import * as THREE from './js/three.module.js';
			import { OrbitControls } from './js/OrbitControls.js';
            // import { NDDEMPhysics } from './js/NDDEMPhysics.js';
			import Stats from './js/stats.module.js';
            import { GUI } from './js/dat.gui.module.js';

			let camera, scene, renderer, stats, panel;
			let physics, position;
            let gui;
			let boxes, spheres;
            let floor, roof, left, right, front, back;
            let S;
            let NDDEMLib;
            let pointer;
            let frameRate = 60;

            var radius = 0.5;
            var L;
            const thickness = radius;

            var params = {
                dimensions: 3,
                L: 3, //system size
                N: 230,
                // packing_fraction: 0.5,
                axial_strain: 0,
                volumetric_strain: 0,
                // gravity: 1,
                paused: false,
            }
            params.packing_fraction = (params.N*4./3.*Math.PI*Math.pow(radius,3))/Math.pow(2*params.L,3);
            params.back = -params.L;
            params.front = params.L;
            params.left = -params.L;
            params.right = params.L;
            params.floor = -params.L;
            params.roof = params.L;

            // update_L();
            //
            // function update_L() {
            //     var L = params.N*4./3.*Math.PI*Math.pow(radius,3);
            //     L = Math.pow(solid_volume/params.packing_fraction,1./3.)
            // }

            var quality = 5;

			init();

			async function init() {

				physics = await NDDEMPhysics();
                // physics.main(params.dimensions, params.N, inputfile)
				position = new THREE.Vector3();

				//

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( 3*params.L, 3*params.L, 1.5*params.L );
                camera.up.set(0, 0, 1);
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x666666 );

                // const axesHelper = new THREE.AxesHelper( 5 );
                // scene.add( axesHelper );

				const hemiLight = new THREE.HemisphereLight();
				hemiLight.intensity = 0.35;
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight();
				dirLight.position.set( 5, 5, 5 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.zoom = 2;
				scene.add( dirLight );

                const wall_geometry = new THREE.BoxGeometry( params.L*2 + thickness*2, thickness, params.L*2 + thickness*2 );
                const wall_material = new THREE.MeshLambertMaterial();
                wall_material.wireframe = true;
                // const wall_material = new THREE.ShadowMaterial( )

				left = new THREE.Mesh( wall_geometry, wall_material );
				left.position.y = - params.L - thickness/2.;
				// floor.receiveShadow = true;
				scene.add( left );
				// physics.addMesh( floor );

                right = new THREE.Mesh( wall_geometry, wall_material );
                right.position.y = params.L + thickness/2.;
                // top.receiveShadow = true;
                scene.add( right );
                // physics.addMesh( roof );

                floor = new THREE.Mesh( wall_geometry, wall_material );
                floor.rotation.x = Math.PI/2.;
				floor.position.z = - params.L - thickness/2.;
				// left.receiveShadow = true;
				scene.add( floor );
				// physics.addMesh( left );

                roof = new THREE.Mesh( wall_geometry, wall_material );
                roof.rotation.x = Math.PI/2.;
				roof.position.z = params.L + thickness/2.;
				// right.receiveShadow = true;
				scene.add( roof );
				// physics.addMesh( right );

                front = new THREE.Mesh( wall_geometry, wall_material );
                front.rotation.z = Math.PI/2.;
                front.position.x = params.L + thickness/2.;
                // back.receiveShadow = true;
                scene.add( front );
                // physics.addMesh( back );

                back = new THREE.Mesh( wall_geometry, wall_material );
                back.rotation.z = Math.PI/2.;
                back.position.x = -params.L - thickness/2.;
                // front.receiveShadow = true;
                scene.add( back );
                // physics.addMesh( front );

				add_spheres();

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.outputEncoding = THREE.sRGBEncoding;
				document.body.appendChild( renderer.domElement );

				stats = new Stats();
                panel = stats.addPanel( new Stats.Panel( 'Pressure', 'white', 'black' ) );
                stats.showPanel( 3 ); // 0: fps, 1: ms, 2: mb, 3+: custom
				document.body.appendChild( stats.dom );

                // gui
				gui = new GUI();

				gui.width = 300;

				gui.domElement.style.userSelect = 'none';

				// const fl = gui.addFolder( 'Intensity' );

				gui.add( params, 'packing_fraction', 0, 1, 0.01 )
					.name( 'Initial density' );//.listen()
					// .onChange( function () { refresh_simulation(); } );
                gui.add( params, 'volumetric_strain', 0,0.2, 0.001)
                    .name( 'Volumetric strain').listen()
                    .onChange( function () { update_walls(); } );
                gui.add( params, 'axial_strain', 0,0.2, 0.001)
                    .name( 'Axial strain').listen()
                    .onChange( function () { update_walls(); } );
                gui.add ( params, 'paused').listen();
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.y = 0.5;
				controls.update();

				animate();
			}

            function update_walls() {
                var L_cur = params.L*(1-params.volumetric_strain);
                var H_cur = L_cur*params.axial_strain; // TODO: THIS FORMULA IS WRONG!!!!!
                params.front = L_cur;
                params.back = -L_cur;
                params.left = -L_cur;
                params.right = L_cur;
                params.floor = -L_cur + H_cur;
                params.roof = L_cur - H_cur;

                S.setBoundary(0, [params.back,params.front]) ; // Set location of the walls in x
                S.setBoundary(1, [params.left,params.right]) ; // Set location of the walls in y
                S.setBoundary(2, [params.floor,params.roof]) ; // Set location of the walls in z
                back.position.x = params.back - thickness/2.;
                front.position.x = params.front + thickness/2.;
                left.position.y = params.left - thickness/2.;
                right.position.y = params.right + thickness/2.;
                floor.position.z = params.floor - thickness/2.;
                roof.position.z = params.roof + thickness/2.;
                // console.log(S.getBoundary(0))
                // console.log(S.getBoundary(1))
                // console.log(S.getBoundary(2))
            }

			function animate() {

				requestAnimationFrame( animate );
                move_spheres();

                if ( !params.paused ) {
                    S.step_forward(100);
                }


                stats.begin()
                var F = S.getWallForce();
                var pressure = (-F[0][0] + F[1][0] - F[2][1] + F[3][1] - F[4][2] + F[5][2])/6.
                // var shear =
                panel.update(pressure,1e6)
                console.log(F);

                stats.end();
                // console.log(window.x)

				//

				// let index = Math.floor( Math.random() * boxes.count );

				// position.set( 0, Math.random() + 1, 0 );
				// physics.setMeshPosition( boxes, position, index );

				//

				// index = Math.floor( Math.random() * spheres.count );

				// position.set( 0, Math.random() + 1, 0 );
				// physics.setMeshPosition( spheres, position, index );

				renderer.render( scene, camera );

				if ( stats !== undefined ) { stats.update(); }

			}
            function refresh_simulation() {
                // update_L();
                // console.log(L)
                var range = 0.8*(L/2 - radius);
                for ( let i = 0; i < params.N; i ++ ) {
                    position.set( range*(2*Math.random() - 1), range*(2*Math.random() - 1), range*(2*Math.random() - 1) );
    				physics.setMeshPosition( spheres, position, i );
                }
                position.set( 0, - L/2 - thickness/2., 0 );
                // physics.setMeshPosition( floor, position );

                floor.position.y = - L/2 - thickness/2.;
                roof.position.y = L/2 + thickness/2.;
                left.position.z = - L/2 - thickness/2.;
                right.position.z = L/2 + thickness/2.;
                back.position.x = L/2 + thickness/2.;
                front.position.x = -L/2 - thickness/2.;
                camera.position.set( - 3*L, 0, 0 );

            }

            function remove_spheres() {
                physics.removeMesh( );
            }

            function add_spheres() {
                const material = new THREE.MeshLambertMaterial();

                const matrix = new THREE.Matrix4();
                const color = new THREE.Color();

                const geometrySphere = new THREE.SphereGeometry( radius, Math.pow(2,quality), Math.pow(2,quality) );
                spheres = new THREE.InstancedMesh( geometrySphere, material, params.N );
                spheres.castShadow = true;
                spheres.receiveShadow = true;
                scene.add( spheres );

                // let x = NDDEMLib.HEAPF64.subarray(pointer, pointer + params.dimensions*params.N);
                var range = 0.8*(L/2 - radius);
                for ( let i = 0; i < params.N; i ++ ) {
                    // matrix.setPosition( x[0 + i*3], x[1 + i*3], x[2 + i*3] );
                    spheres.setMatrixAt( i, matrix );
                    spheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );

                }

                // physics.addMesh( spheres, 1 );
            }

            function move_spheres() {
                var x = S.getX();
                for ( let i = 0; i < params.N; i ++ ) {
                    const matrix = new THREE.Matrix4();
                    // console.log(x[i])
                    matrix.setPosition( x[i][0], x[i][1], x[i][2] );
                    spheres.setMatrixAt( i, matrix );
                }
                spheres.instanceMatrix.needsUpdate = true;
                // console.log(x)
                // physics.addMesh( spheres, 1 );
            }

            async function NDDEMPhysics() {

            	if ( 'DEMND' in window === false ) {

            		console.error( 'NDDEMPhysics: Couldn\'t find DEMND.js' );
            		return;

            	}

            	NDDEMLib = await DEMND(); // eslint-disable-line no-undef
                const Dimensions = 3;


                S = await new NDDEMLib.Simulation (params.N);
                S.interpret_command("dimensions 3 " + String(params.N));
                S.interpret_command("radius -1 0.5");
                S.interpret_command("mass -1 1");
                S.interpret_command("auto rho");
                S.interpret_command("auto inertia");

                S.interpret_command("boundary 0 WALL -"+String(params.L)+" "+String(params.L));
                S.interpret_command("boundary 1 WALL -"+String(params.L)+" "+String(params.L));
                S.interpret_command("boundary 2 WALL -"+String(params.L)+" "+String(params.L));
                // S.interpret_command("boundary 1 WALL 0 5");
                // S.interpret_command("boundary 2 WALL 0 3.4");
                S.interpret_command("auto location randomdrop");
                // S.interpret_command("gravity -"+String(params.gravity)+" 0 0");
                S.interpret_command("gravity -0.9 0.42 0")

                // NONE OF THESE DO ANYTHING YET
                S.interpret_command("set Kn 2e5");
                S.interpret_command("set Kt 8e4");
                S.interpret_command("set GammaN 75");
                S.interpret_command("set GammaT 75");
                S.interpret_command("set Mu 0.5");
                S.interpret_command("set T 150");
                S.interpret_command("set dt 0.0001");


            }

		</script>
	</body>
</html>

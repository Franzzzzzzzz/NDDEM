<!DOCTYPE html>
<html lang="en">
	<head>
		<title>NDDEM in the browser</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
            #N_tag {
                color: white;
                padding: 24px;
                font: 48px Montserrat;
                /* font-weight: bold; */
                position:absolute;
            }
            #stats {
                position: absolute;
                width: 300px;
                height: 200px;
                margin: 0;
                padding: 0;
            }
        </style>
	</head>
	<body>
        <div id="stats"></div>
        <script async type="text/javascript" src="../bin/DEMND.js"></script>
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

		<script type="module">

			// import * as THREE from './js/three.module.js';
            import * as THREE from "../visualise/node_modules/three/build/three.module.js";
			import { OrbitControls } from './js/OrbitControls.js';
            // import { NDDEMPhysics } from './js/NDDEMPhysics.js';
			import Stats from './js/stats.module.js';
            import { GUI } from './js/dat.gui.module.js';
            import { Lut } from './js/Lut.js'
            import { PIDcontroller } from './js/PIDcontroller.js'
            import { NDSTLLoader, renderSTL } from './js/NDSTLLoader.js';

            var urlParams = new URLSearchParams(window.location.search);
            var clock = new THREE.Clock();

			let camera, scene, renderer, stats, panel;
			let physics, position;
            let gui;
			let boxes, spheres;
            let floor, roof, left, right, front, back;
            let S;
            let NDDEMLib;
            let pointer;
            let frameRate = 60;
            let v;
            let pressure = 0;
            let shear = 0;
            let density = 0;
            let pressure_time = [];
            let shear_time = [];
            let density_time = [];
            let particle_volume;
            let started = false;
            let show_stats = true;
            const material_density = 2700;
            let old_time = 0;
            let new_time = 0;
            let counter = 0;
            let p_controller, q_controller;
            let NDsolids, material, STLFilename;
            let meshes = new THREE.Group();

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let intersection_plane = new THREE.Plane();
            let camera_direction = new THREE.Vector3();

            let INTERSECTED = null;
            let last_intersection = null;
            let locked_particle = null;
            let ref_location;

            var params = {
                radius: 0.05,
                dimension: 4,
                L1: 2,
                L2: 1,
                L3: 0.1, // this is the direction of gravity
                L4: 1,
                pyramid_size: 5,
                // packing_fraction: 0.5,
                axial_strain: 0,
                volumetric_strain: 0,
                gravity: true,
                paused: false,
                H_cur: 0,
                pressure_set_pt: 1e4,
                deviatoric_set_pt: 0,
                d4_cur:0,
                dt: 0.0005
            }

            params.N = get_num_particles(params.pyramid_size);

            var quality = 5;

            var NDParticleShader;
            import("../visualise/js/shaders/" + params.dimension + "DShader.js").then((module) => {
                NDParticleShader = module.NDDEMShader;
    			init();
            });

			async function init() {

				physics = await NDDEMPhysics();
                // physics.main(params.dimensions, params.N, inputfile)
				position = new THREE.Vector3();

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( 2*params.L1, 2*params.L2, 2*params.L3 );
                camera.up.set(0, 0, 1);
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x666666 );

				const hemiLight = new THREE.HemisphereLight();
				hemiLight.intensity = 0.35;
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight();
				dirLight.position.set( 0, 0, 5 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.zoom = 2;
				scene.add( dirLight );

				add_spheres();

                STLFilename = './stls/4d-pool.stl';
                const texture = new THREE.TextureLoader().load( 'textures/golfball.jpg', function(t) {
                    // t.encoding = THREE.sRGBEncoding;
                    t.mapping = THREE.EquirectangularReflectionMapping;
                } );
                material = new THREE.MeshPhongMaterial( {
                    color: 0x00aa00,
                    // map: texture,
                } );
                material.side = THREE.DoubleSide;
                loadSTL();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.outputEncoding = THREE.sRGBEncoding;
				document.body.appendChild( renderer.domElement );

                // gui
				gui = new GUI();

				gui.width = 300;

                gui.add( params, 'd4_cur', -params.L4,params.L4, 0.001)
                    .name( 'D4 location').listen()
                    .onChange( function () {
                        if ( urlParams.has('stl') ) {
                            meshes = renderSTL( meshes, NDsolids, scene, material, params.d4_cur );
                        }
                    });
                gui.add ( params, 'gravity').name('Gravity').listen()
                    .onChange( function() {
                        if ( params.gravity === true ) {
                            S.interpret_command("gravity 0 0 -1000 " + "0 ".repeat(params.dimension - 3)) }
                        else {
                            S.interpret_command("gravity 0 0 0 " + "0 ".repeat(params.dimension - 3)) }
                        });
                gui.add ( params, 'paused').name('Paused').listen();
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.y = 0.5;
				controls.update();

                window.addEventListener( 'resize', onWindowResize, false );
                window.addEventListener( 'mousemove', onMouseMove, false );
                window.addEventListener( 'keypress', onSelectParticle, false );

			    animate();
			}

            function onMouseMove( event ) {

            	// calculate mouse position in normalized device coordinates
            	// (-1 to +1) for both components

            	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

            }

            function onSelectParticle( event ) {
                // console.log(camera.getWorldDirection() )
                if ( event.key === 'Enter' ) {
                    // console.log('hit!')
                    var work = 1.
                    var force = work/params.dt;
                    S.setExternalForce(0, 1, [-force,0.0,0.,0.]);

                }
                if ( event.code === 'Space' ) {
                    if ( locked_particle === null ) {
                        locked_particle = INTERSECTED;
                        // console.log(locked_particle);
                        ref_location = locked_particle.position;

                        camera.getWorldDirection( camera_direction ); // update camera direction
                        // set the plane for the particle to move along to be orthogonal to the camera
                        intersection_plane.setFromNormalAndCoplanarPoint( camera_direction,
                                                                          locked_particle.position );
                    }
                    else {
                        locked_particle = null;
                    }
                }
                else if ( event.key === "w" ) {
                    params.d4_cur += 0.1*params.radius;
                    meshes = renderSTL( meshes, NDsolids, scene, material, params.d4_cur );
                }
                else if ( event.key === "s" ) {
                    params.d4_cur -= 0.1*params.radius;
                    meshes = renderSTL( meshes, NDsolids, scene, material, params.d4_cur );
                }
            }


            function onWindowResize(){

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

			function animate() {
                if ( clock.getElapsedTime() > 1 ) { started = true; }
				requestAnimationFrame( animate );
                move_spheres();
                if ( locked_particle !== null ) {
                    // console.log(locked_particle)
                    // if ( raycaster.ray.intersectsPlane( intersection_plane ) ) { // if the mouse is over the plane - why would i need to check this?
                        // console.log('success!')
        				// ref_location.position.copy( _intersection.sub( _offset ).applyMatrix4( _inverseMatrix ) );
        			// }
                    // ref_location.x = mouse.x;
                    raycaster.ray.intersectPlane( intersection_plane, ref_location);
                    ref_location.clamp( new THREE.Vector3(-params.L1, -params.L2,0),
                                        new THREE.Vector3( params.L1,  params.L2,0) );
                    // if ( ref_location.x > back.position.x + radius && ref_location.x < front.position.x - radius ) {
                        // console.log(ref_location.x)
                        // console.log(back.position.x)
                    S.fixParticle(locked_particle.NDDEM_ID,[ref_location.x, ref_location.y, ref_location.z]);
                    // }
                }

                if ( !params.paused ) {
                    S.step_forward(20);
                }

                // console.log(S.getTime())
                // update the picking ray with the camera and mouse position
            	raycaster.setFromCamera( mouse, camera );


                // const intersects = raycaster.intersectObjects( spheres.children );
				// if ( intersects.length > 0 ) { // if found something
				// 	if ( INTERSECTED != intersects[ 0 ].object ) { // if not the same as last time
                //             if ( INTERSECTED !== null ) { INTERSECTED.material.uniforms.ambient.value = 1.0; }
    			// 			INTERSECTED = intersects[ 0 ].object;
                //             INTERSECTED.material.uniforms.ambient.value = 5.0;
				// 	}
				// }
                // else { // didn't find anything
				// 	if ( INTERSECTED !== null ) { // there was something before
                //         INTERSECTED.material.uniforms.ambient.value = 1.0;
                //         INTERSECTED = null;
                //     }
				// }


				renderer.render( scene, camera );

				if ( stats !== undefined ) { stats.update(); }

                old_time = new_time;

			}
            // function refresh_simulation() {
            //     // update_L();
            //     // console.log(L)
            //     var range = 0.8*(L/2 - radius);
            //     for ( let i = 0; i < params.N; i ++ ) {
            //         position.set( range*(2*Math.random() - 1), range*(2*Math.random() - 1), range*(2*Math.random() - 1) );
    		// 		physics.setMeshPosition( spheres, position, i );
            //     }
            //     position.set( 0, - L/2 - thickness/2., 0 );
            //
            //     floor.position.y = - L/2 - thickness/2.;
            //     roof.position.y = L/2 + thickness/2.;
            //     left.position.z = - L/2 - thickness/2.;
            //     right.position.z = L/2 + thickness/2.;
            //     back.position.x = L/2 + thickness/2.;
            //     front.position.x = -L/2 - thickness/2.;
            //     camera.position.set( - 3*L, 0, 0 );
            //
            // }

            function add_spheres() {
                spheres = new THREE.Group();
                scene.add(spheres);
                // const material = new THREE.MeshStandardMaterial();


                // const matrix = new THREE.Matrix4();
                const color = new THREE.Color();

                const geometrySphere = new THREE.SphereGeometry( 0.5, Math.pow(2,quality), Math.pow(2,quality) );
                // const geometrySphere = new THREE.BufferGeometry().fromGeometry(
                //   new THREE.SphereGeometry(
                //     1,
                //     Math.pow(2, params.quality),
                //     Math.pow(2, params.quality)
                //   )
                // );
                // spheres = new THREE.InstancedMesh( geometrySphere, material, params.N );
                // spheres.castShadow = true;
                // spheres.receiveShadow = true;
                // scene.add( spheres );

                for ( let i = 0; i < params.N; i ++ ) {
                    const material = NDParticleShader.clone();
                    var object = new THREE.Mesh(geometrySphere, material);
                    object.position.set(0,0,0);
                    object.rotation.z = Math.PI / 2;
                    object.NDDEM_ID = i;
                    object.castShadow = true;
                    object.material.uniforms.R.value = params.radius;
                    spheres.add(object);

                    // spheres.setMatrixAt( i, matrix );
                    // spheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );

                }
                // display white ball
                spheres.children[0].material.uniforms.banding.value = 1.;
                spheres.children[0].material.uniforms.ambient.value = 5.;
            }

            function move_spheres() {
                var x = S.getX();
                var orientation = S.getOrientation();
                if ( urlParams.has('lut') ) {
                    if ( urlParams.get('lut') === 'velocity' ) {
                        v = S.getVelocity();
                    }
                    // spheres.instanceColor.needsUpdate = true;

                }
                for ( let i = 0; i < params.N; i ++ ) {
                    var object = spheres.children[i];

                    // const matrix = new THREE.Matrix4();
                    // matrix.setPosition( x[i][0], x[i][1], x[i][2] );
                    if ( params.dimension == 4 ) {
                        var D_draw = 2*Math.sqrt(
                          Math.pow(params.radius, 2) - Math.pow(params.d4_cur - x[i][3], 2)
                        );
                        object.scale.set(D_draw, D_draw, D_draw);
                        // matrix.scale( new THREE.Vector3(D_draw,D_draw,D_draw) );
                    }
                    // spheres.setMatrixAt( i, matrix );
                    object.position.set( x[i][0], x[i][1], x[i][2] );
                    if ( urlParams.has('lut') ) {
                        if ( urlParams.get('lut') === 'velocity' ) {
                            spheres.setColorAt( i, lut.getColor( 1e-4*( Math.pow(v[i][0],2) + Math.pow(v[i][1],2) + Math.pow(v[i][2],2) ) ) );
                        }
                    }
                    for (var j = 0; j < params.N - 3; j++) {
                      object.material.uniforms.xview.value[j] =
                        params.d4_cur;
                      object.material.uniforms.xpart.value[j] =
                        x[i][j + 3];
                    }
                    object.material.uniforms.A.value = orientation[i];
                    // if (params.dimension > 3) {
                    //   object.material.uniforms.x4p.value = x[i][j + 3];
                    //   object.material.uniforms.x4.value = params.d4_cur;
                    // } else {
                    //   object.material.uniforms.x4p.value = 0.0;
                    // }
                }
                // spheres.instanceMatrix.needsUpdate = true;
                // console.log(orientation[0])
            }

            async function NDDEMPhysics() {

            	if ( 'DEMND' in window === false ) {

            		console.error( 'NDDEMPhysics: Couldn\'t find DEMND.js' );
            		return;

            	}

            	NDDEMLib = await DEMND(); // eslint-disable-line no-undef

                if ( params.dimension == 3 ) {
                    S = await new NDDEMLib.Simulation3 (params.N);
                    finish_setup();
                }
                else if ( params.dimension == 4 ) {
                    S = await new NDDEMLib.Simulation4 (params.N);
                    finish_setup();
                }



                function finish_setup() {
                    S.interpret_command("dimensions " + String(params.dimension) + " " + String(params.N));
                    S.interpret_command("radius -1 " + String(params.radius));
                    S.interpret_command("mass -1 0.1");
                    S.interpret_command("auto rho");
                    S.interpret_command("auto inertia");

                    S.interpret_command("boundary 0 WALL -"+String(params.L1)+" "+String(params.L1));
                    S.interpret_command("boundary 1 WALL -"+String(params.L2)+" "+String(params.L2));
                    S.interpret_command("boundary 2 WALL -"+String(params.L3)+" "+String(params.L3));
                    S.interpret_command("boundary 3 WALL -"+String(params.L4)+" "+String(params.L4));
                    S.interpret_command("gravity 0 0 -10 0")
                    // S.interpret_command("auto location randomdrop");

                    let n = 1;
                    let offset = params.L1/2;

                    S.interpret_command("location " + String(0) + " " + String(offset) + " " + String(0) + " " + String(-params.L3+params.radius) + " " + String(0)); // first ball is the white ball

                    for ( var k=0; k<params.pyramid_size; k++ ) {
                        let cur_pyramid_length = params.pyramid_size - k;
                        let w = k*1.825*params.radius;
                        for ( var i=0; i<cur_pyramid_length; i++ ) {
                            for ( var j=0; j<cur_pyramid_length - i; j++) {
                                let x = i*1.82*params.radius - cur_pyramid_length*params.radius + params.radius - offset;
                                let y = j*2.01*params.radius - (cur_pyramid_length-i)*params.radius + params.radius;// - i%2*radius;
                                // console.log(x,y);
                                S.interpret_command("location " + String(n) + " " + String(x) + " " + String(y) + " " + String(-params.L3+params.radius) + " " + String(w));
                                n++;
                                if ( k > 0 ) { S.interpret_command("location " + String(n) + " " + String(x) + " " + String(y) + " " + String(-params.L3+params.radius) + " " + String(-w)); n++;}

                            }
                        }
                    }
                    S.interpret_command("set Kn 2e5");
                    S.interpret_command("set Kt 8e4");
                    S.interpret_command("set GammaN 75");
                    S.interpret_command("set GammaT 75");
                    S.interpret_command("set Mu 0.5");
                    S.interpret_command("set T 150");
                    S.interpret_command("set dt " + String(params.dt));
                    S.finalise_init () ;
                }
            }

            function loadSTL( ) {

                const loader = new NDSTLLoader();
				loader.load( [ STLFilename ], function ( solids ) {
                    NDsolids = solids;
                    meshes = renderSTL(meshes, NDsolids, scene, material, params.d4_cur);
				} )
            }

            function get_num_particles(L) {
                let N = 0;
                let i = 1;
                for (var n=L; n>0; n--) {
                    // console.log(n,i,i*n)
                    N += i*n;
                    i += 2;
                }
                return N+1; // adding the white ball
            }

		</script>
	</body>
</html>

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>NDDEM Triaxial</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <link rel="icon" type="image/x-icon" href="../visualise/resources/favicon.ico">
        <link rel="stylesheet" href="css/main.css">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-GQE06JN33T"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-GQE06JN33T');
        </script>
	</head>
	<body>
        <div id="scigem_tag">
            Simulated with <a href="https://github.com/Franzzzzzzzz/NDDEM/">NDDEM</a> and <a href="https://threejs.org/">three.js</a> by <a href="http://francoisguillard.com/en/welcome/">Fran√ßois Guillard</a> and <a href="http://benjymarks.com/">Benjy Marks</a>
        </div>
        <div class="flex-container">
            <div id="stats">
                <a href="#" id="download_tag" title="Download data as a csv file" class="material-icons hidden">file_download</a>
            </div>
            <div id="canvas"></div>
        </div>
        <!-- <script async type="text/javascript" src="./deploy/DEMND.js"></script> -->
        <script async type="text/javascript" src="../deploy/DEMCGND.js"></script>
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

		<script type="module">

			// import * as THREE from './js/three.module.js';
            import * as THREE from "../visualise/node_modules/three/build/three.module.js";
			import { OrbitControls } from './js/OrbitControls.js';
            // import { NDDEMPhysics } from './js/NDDEMPhysics.js';
			import Stats from './js/stats.module.js';
            import { GUI } from './js/dat.gui.module.js';
            import { Lut } from './js/Lut.js'
            import { PIDcontroller } from './js/PIDcontroller.js'
            import { NDSTLLoader, renderSTL } from './js/NDSTLLoader.js';

            var urlParams = new URLSearchParams(window.location.search);
            var clock = new THREE.Clock();

			let camera, scene, renderer, stats, panel;
			let physics, position;
            let gui;
			let boxes, spheres;
            let floor, roof, left, right, front, back;
            let S;
            let NDDEMCGLib;
            let pointer;
            let frameRate = 60;
            let v, omegaMag;
            let pressure = 0;
            let shear = 0;
            let density = 0;
            let pressure_time = [];
            let shear_time = [];
            let density_time = [];
            // var radius = 0.5;
            let radii;
            let particle_volume;
            let started = false;
            let stressTcxx, stressTcyy, stressTczz, stressTcxy;
            let show_stats = true;
            // const thickness = radius;
            const material_density = 2700;
            let old_time = 0;
            let new_time = 0;
            let counter = 0;
            let p_controller, q_controller;
            let NDsolids, material, STLFilename;
            let meshes = new THREE.Group();

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let intersection_plane = new THREE.Plane();
            let camera_direction = new THREE.Vector3();

            let INTERSECTED = null;
            let last_intersection = null;
            let locked_particle = null;
            let ref_location;

            let loading_method = 'strain_controlled';
            if ( urlParams.has('stress_controlled') ) {
                loading_method = 'stress_controlled';
            }

            let graph_fraction = 0.5;
            document.getElementById("stats").style.width = String(100*graph_fraction) + '%';
            document.getElementById("canvas").style.width = String(100*(1-graph_fraction)) + '%';

            var params = {
                dimension: 3,
                L: 4, //system size
                N: 500,
                // packing_fraction: 0.5,
                constant_volume: true,
                axial_strain: 0,
                volumetric_strain: 0,
                gravity: false,
                paused: false,
                H_cur: 0,
                W_cur: 0,
                pressure_set_pt: 1e4,
                deviatoric_set_pt: 0,
                d4_cur:0,
                r_max: 0.5,
                r_min: 0.45,
                freq: 0.05,
                new_line: false,
								clear_line: false,
                loading_rate: 0.001,
                max_volumetric_strain: 0.2,
                max_axial_strain: 0.2,
                lut: 'None',
            }

            params.average_radius = (params.r_min + params.r_max)/2.;
            let thickness = params.average_radius;

            particle_volume = 4./3.*Math.PI*Math.pow(params.average_radius,3);
            if ( urlParams.has('dimension') ) {
                params.dimension = parseInt(urlParams.get('dimension'));
            }
            if ( params.dimension === 4) {
                params.L = 2.5;
                params.N = 300
                particle_volume = Math.PI*Math.PI*Math.pow(params.average_radius,4)/2.;
            }
            if ( urlParams.has('no_stats') ) {
                show_stats = false;
            }


            params.L_cur = params.L;
            params.packing_fraction = params.N*particle_volume/Math.pow(2*params.L,3);
            params.back = -params.L;
            params.front = params.L;
            params.left = -params.L;
            params.right = params.L;
            params.floor = -params.L;
            params.roof = params.L;

            // update_L();
            //
            // function update_L() {
            //     var L = params.N*4./3.*Math.PI*Math.pow(radius,3);
            //     L = Math.pow(solid_volume/params.packing_fraction,1./3.)
            // }

            const lut = new Lut( 'blackbody', 512 );

            if ( params.dimension == 3 ) {
                p_controller = new PIDcontroller(1e-6,1e-9,0);
                q_controller = new PIDcontroller(1e-6,1e-9,0);
            }
            // else {
            //     p_controller = new PIDcontroller(1e-7,1e-6,0);
            //     q_controller = new PIDcontroller(1e-6,1e-5,0);
            // }

            var quality = 5;

            var NDParticleShader;
            import("../visualise/js/shaders/" + params.dimension + "DShader.js").then((module) => {
                NDParticleShader = module.NDDEMShader;
    			init();
            });

			async function init() {

				physics = await NDDEMPhysics();
                // physics.main(params.dimensions, params.N, inputfile)
				position = new THREE.Vector3();

				//

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth*(1-graph_fraction) / window.innerHeight, 0.1, 1000 );
				camera.position.set( 3*params.L, 3*params.L, 1.5*params.L );
                camera.up.set(0, 0, 1);
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x111 );

                // const axesHelper = new THREE.AxesHelper( 5 );
                // scene.add( axesHelper );

				const hemiLight = new THREE.HemisphereLight();
				hemiLight.intensity = 0.35;
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight();
				dirLight.position.set( 5, 5, 5 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.zoom = 2;
				scene.add( dirLight );

                // const wall_geometry = new THREE.BoxGeometry( params.L*2 + thickness*2, thickness, params.L*2 + thickness*2 );
                const wall_geometry = new THREE.BoxGeometry( 1, thickness, 1 );
                const wall_material = new THREE.MeshLambertMaterial();
                wall_material.wireframe = true;
                // const wall_material = new THREE.ShadowMaterial( )

				left = new THREE.Mesh( wall_geometry, wall_material );
				left.position.y = - params.L - thickness/2.;
				// floor.receiveShadow = true;
				scene.add( left );
				// physics.addMesh( floor );

                right = new THREE.Mesh( wall_geometry, wall_material );
                right.position.y = params.L + thickness/2.;
                // top.receiveShadow = true;
                scene.add( right );
                // physics.addMesh( roof );

                floor = new THREE.Mesh( wall_geometry, wall_material );
                floor.rotation.x = Math.PI/2.;
				floor.position.z = - params.L - thickness/2.;
				// left.receiveShadow = true;
				scene.add( floor );
				// physics.addMesh( left );

                roof = new THREE.Mesh( wall_geometry, wall_material );
                roof.rotation.x = Math.PI/2.;
				roof.position.z = params.L + thickness/2.;
				// right.receiveShadow = true;
				scene.add( roof );
				// physics.addMesh( right );

                front = new THREE.Mesh( wall_geometry, wall_material );
                front.rotation.z = Math.PI/2.;
                front.position.x = params.L + thickness/2.;
                // back.receiveShadow = true;
                scene.add( front );
                // physics.addMesh( back );

                back = new THREE.Mesh( wall_geometry, wall_material );
                back.rotation.z = Math.PI/2.;
                back.position.x = -params.L - thickness/2.;
                // front.receiveShadow = true;
                scene.add( back );
                // physics.addMesh( front );

				add_spheres();

                if ( urlParams.has('stl') ) {
                    STLFilename = './stls/4d-pool.stl';
                    material = new THREE.MeshPhongMaterial( { color: 0x00aa00 } );
                    material.side = THREE.DoubleSide;
                    loadSTL();
                }

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth*(1-graph_fraction), window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.outputEncoding = THREE.sRGBEncoding;

                var container = document.getElementById( 'canvas' );
                // document.body.appendChild( container );
                container.appendChild( renderer.domElement );

				// stats = new Stats();
                // panel = stats.addPanel( new Stats.Panel( 'Pressure', 'white', 'black' ) );
                // stats.showPanel( 3 ); // 0: fps, 1: ms, 2: mb, 3+: custom
				// // document.body.appendChild( stats.dom );
                // var thisParent = document.getElementById("stats");
                // thisParent.appendChild( stats.domElement );
                //
                // var statsALL = document.getElementById("stats").querySelectorAll("canvas");
                //
                // for(var i=0; i<statsALL.length; i++){
                //     statsALL[i].style.width = "240px";
                //     statsALL[i].style.height = "160px";
                // }

                // gui
				gui = new GUI();
                // console.log(gui)
				gui.width = 350;

				// gui.add( params, 'packing_fraction', 0, 1, 0.01 )
					// .name( 'Solids fraction' ).listen();
					// .onChange( function () { refresh_simulation(); } );
                if ( loading_method === 'strain_controlled' ) {
                    gui.add( params, 'volumetric_strain', 0, params.max_volumetric_strain, 0.001)
                        .name( 'Volumetric strain (W/S)').listen()
                        .onChange( function () { update_walls(); } );
                    gui.add( params, 'axial_strain', -params.max_axial_strain,params.max_axial_strain, 0.001)
                        .name( 'Axial strain (A/D)').listen()
                        .onChange( function () { update_walls(); } );
                    gui.add( params, 'loading_rate', 0.0001, 0.01, 0.0001).name( 'Loading rate' );
                    gui.add ( params, 'constant_volume')
                        .name('Constant volume').listen()
                        .onChange( function() { update_walls(); });
                    }
                else if ( loading_method === 'stress_controlled' ) {
                    gui.add( params, 'pressure_set_pt', 0,1e5, 1)
                        .name( 'Pressure set point (W/S)').listen()
                        .onChange( function () { update_walls(); } );
                    gui.add( params, 'deviatoric_set_pt', -1e5,1e5, 1)
                        .name( 'Deviatoric stress set point (A/D)').listen()
                        .onChange( function () { update_walls(); } );
                    }
                if ( params.dimension == 4 ) {
                    gui.add( params, 'd4_cur', -params.L,params.L, 0.001)
                        .name( 'D4 location').listen()
                        // .onChange( function () { update_walls(); } );
                        .onChange( function () {
                            if ( urlParams.has('stl') ) {
                                meshes = renderSTL( meshes, NDsolids, scene, material, params.d4_cur );
                            }
                        });
                }
                gui.add ( params, 'lut', ['None', 'Velocity', 'Rotation Rate' ]).name('Colour by')
                    .onChange( () => {
                        if ( params.lut === 'None' ) {
                            for ( let i = 0; i < params.N; i ++ ) {
                                var object = spheres.children[i];
                                object.material.uniforms.ambient.value = 1;
                            }
                        }
                    });
                gui.add ( params, 'gravity').name('Gravity').listen()
                    .onChange( function() {
                        if ( params.gravity === true ) {
                            S.simu_interpret_command("gravity 0 0 -1000 " + "0 ".repeat(params.dimension - 3)) }
                        else {
                            S.simu_interpret_command("gravity 0 0 0 " + "0 ".repeat(params.dimension - 3)) }
                        });
                gui.add ( params, 'paused').name('Paused (Enable to rotate graph)').listen();
                gui.add ( params, 'new_line').name('New loading path').listen()
                    .onChange( () => {
                        params.axial_strain = 0;
                        params.volumetric_strain = 0;
                        params.pressure_set_pt = 10000;
                        params.deviatoric_set_pt = 0;
                        update_walls();
                        var data = [{
                                      type: 'scatter3d',
                                      mode: 'lines',
                                      x: [], y: [], z: [],
                                      line: { width: 5 },
                                      name: 'Load path ' + String(document.getElementById('stats').data.length+1)
                                    }]
                        Plotly.addTraces('stats', data);
                        params.new_line = false;
                    });
								gui.add ( params, 'clear_line').name('Clear line').listen()
		                    .onChange( () => {
														Plotly.deleteTraces('stats', [-1])
		                        var data = [{
		                                      type: 'scatter3d',
		                                      mode: 'lines',
		                                      x: [], y: [], z: [],
		                                      line: { width: 5 },
		                                      name: 'Load path ' + String(document.getElementById('stats').data.length+1)
		                                    }]
		                        Plotly.addTraces('stats', data);
		                        params.clear_line = false;
		                    });
				const controls = new OrbitControls( camera, container );
				controls.target.y = 0.5;
				controls.update();

                window.addEventListener( 'resize', onWindowResize, false );
                container.addEventListener( 'mousemove', onMouseMove, false );
                window.addEventListener( 'keypress', onSelectParticle, false );

                if ( show_stats ) { make_graph(); }

                update_walls();
			    animate();
			}

            function onMouseMove( event ) {

            	// calculate mouse position in normalized device coordinates
            	// (-1 to +1) for both components
            	mouse.x = ( (event.clientX - window.innerWidth*graph_fraction) / window.innerWidth*(1-graph_fraction) ) * 8 - 1;
            	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

            }

            function onSelectParticle( event ) {
                if ( event.code === 'KeyW' ) {
                    if ( loading_method === 'strain_controlled' && params.volumetric_strain < params.max_volumetric_strain) { params.volumetric_strain += params.loading_rate; }
                    else { params.pressure_set_pt *= 1 + params.loading_rate; }
                    update_walls();
                    }
                if ( event.code === 'KeyS' ) {
                    if ( loading_method === 'strain_controlled' && params.volumetric_strain > 0 ) { params.volumetric_strain -= params.loading_rate; }
                    else { params.pressure_set_pt /= 1 + params.loading_rate; }
                    update_walls();
                    }
                if ( event.code === 'KeyD' ) {
                    if ( loading_method === 'strain_controlled' && params.axial_strain < params.max_axial_strain ) { params.axial_strain += params.loading_rate; }
                    // else if ( params.deviatoric_set_pt === 0 ) { params.deviatoric_set_pt = 1; }
                    else { params.deviatoric_set_pt += params.loading_rate*params.pressure_set_pt; }
                    update_walls();
                    }
                if ( event.code === 'KeyA' && params.axial_strain > -params.max_axial_strain ) {
                    if ( loading_method === 'strain_controlled' ) { params.axial_strain -= params.loading_rate; }
                    // else if ( params.deviatoric_set_pt === 0 ) { params.deviatoric_set_pt = -1; }
                    else { params.deviatoric_set_pt -= params.loading_rate*params.pressure_set_pt; }
                    update_walls();
                    }
                if ( event.code === 'Space' ) {
                    if ( locked_particle === null ) {
                        locked_particle = INTERSECTED;
                        // console.log(locked_particle);
                        ref_location = locked_particle.position;

                        camera.getWorldDirection( camera_direction ); // update camera direction
                        // set the plane for the particle to move along to be orthogonal to the camera
                        intersection_plane.setFromNormalAndCoplanarPoint( camera_direction,
                                                                          locked_particle.position );
                    }
                    else {
                        locked_particle = null;
                    }
                }
            }


            function onWindowResize(){

                camera.aspect = window.innerWidth*(1-graph_fraction) / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth*(1-graph_fraction), window.innerHeight );

                var update = {
                    width: window.innerWidth*graph_fraction,
                    height: window.innerHeight
                    };
                Plotly.relayout('stats', update);

            }

            function update_walls(dt=0.001) {
                params.packing_fraction = (params.N*particle_volume)/Math.pow(params.L_cur-params.W_cur,params.dimension-1)/(params.L_cur - params.H_cur)/Math.pow(2,params.dimension);
                // console.log(params.packing_fraction) // NOTE: STILL A BIT BUGGY!!!!

                if ( loading_method == 'strain_controlled') {
                    if ( params.constant_volume ) {
                        params.L_cur = params.L*(1-params.volumetric_strain);
                        params.H_cur = params.L*params.axial_strain;
                        params.W_cur = -( -Math.sqrt(params.L*params.L*params.L*(params.L-params.H_cur)) - params.H_cur*params.L + params.L*params.L ) / ( params.H_cur - params.L );
                        // console.log(params.L_cur, params.H_cur, params.W_cur);

                    }
                    else {
                        params.L_cur =  params.L*(1-params.volumetric_strain);
                        params.H_cur =  params.L*params.axial_strain;
                        params.W_cur = 0;
                    }


                }
                else if ( loading_method == 'stress_controlled' ) {
                    let delta_p = p_controller.update(params.pressure_set_pt,pressure,dt);
                    let delta_q = q_controller.update(params.deviatoric_set_pt,shear,dt)
                    // console.log(pressure)
                    params.L_cur -= delta_p;
                    params.H_cur += delta_q;

                }
                params.front =  params.L_cur - params.W_cur;
                params.back  = -params.L_cur + params.W_cur;
                params.left  = -params.L_cur + params.W_cur;
                params.right =  params.L_cur - params.W_cur;
                params.floor = -params.L_cur + params.H_cur;
                params.roof  =  params.L_cur - params.H_cur;

                S.simu_setBoundary(0, [params.back,params.front]) ; // Set location of the walls in x
                S.simu_setBoundary(1, [params.left,params.right]) ; // Set location of the walls in y
                S.simu_setBoundary(2, [params.floor,params.roof]) ; // Set location of the walls in z
                for (var j = 0; j < params.dimension - 3; j++) {
                    S.simu_setBoundary(j + 3, [-params.L_cur,params.L_cur]) ; // Set location of the walls in z
                }
                back.position.x = params.back - thickness/2.;
                front.position.x = params.front + thickness/2.;
                left.position.y = params.left - thickness/2.;
                right.position.y = params.right + thickness/2.;
                floor.position.z = params.floor - thickness/2.;
                roof.position.z = params.roof + thickness/2.;

                var horiz_walls = [floor,roof];
                var vert_walls = [left,right,front,back];

                vert_walls.forEach( function(mesh) {
                    mesh.scale.x = 2*params.L_cur + 2*thickness;
                    mesh.scale.z = 2*(params.L_cur-params.H_cur) + 2*thickness;
                });

                horiz_walls.forEach( function(mesh) {
                    mesh.scale.x = 2*params.L_cur + 2*thickness;
                    mesh.scale.z = 2*params.L_cur + 2*thickness;
                });

            }

			function animate() {
                if ( clock.getElapsedTime() > 3 ) { started = true; }
				requestAnimationFrame( animate );
                move_spheres();
                if ( locked_particle !== null ) {
                    // console.log(locked_particle)
                    // if ( raycaster.ray.intersectsPlane( intersection_plane ) ) { // if the mouse is over the plane - why would i need to check this?
                        // console.log('success!')
        				// ref_location.position.copy( _intersection.sub( _offset ).applyMatrix4( _inverseMatrix ) );
        			// }
                    // ref_location.x = mouse.x;
                    raycaster.ray.intersectPlane( intersection_plane, ref_location);
                    ref_location.clamp( new THREE.Vector3(back.position.x,  left.position.y,floor.position.z),
                                        new THREE.Vector3(front.position.x,right.position.y, roof.position.z) );
                    // if ( ref_location.x > back.position.x + radius && ref_location.x < front.position.x - radius ) {
                        // console.log(ref_location.x)
                        // console.log(back.position.x)
                    S.simu_fixParticle(locked_particle.NDDEM_ID,[ref_location.x, ref_location.y, ref_location.z]);
                    // }
                }

                if ( !params.paused ) {
                    new_time = clock.getElapsedTime()

                        if ( show_stats && started ) {
                            // counter = counter + 1;
                            // if ( counter == 5 ) { update_graph(); counter = 0; }
                            update_graph();
                    }

                    if (loading_method === 'stress_controlled') {
                        update_walls(new_time - old_time); // TODO: MAKE THIS WORK BETTER WHEN THE SYSTEM IS PAUSED i.e. DIFFERENCE BETWEEN WALLTIME AND REAL TIME
                    }
                    S.simu_step_forward(5);

                    // var F = S.simu_getWallForce();
                    //
                    // if ( F.length > 1 ) { // returns an empty array if hasn't calculated yet
                    //     let sigma_11 = (-F[0][0] + F[1][0])/2/params.L_cur/params.L_cur;
                    //     let sigma_22 = (-F[2][1] + F[3][1])/2/params.L_cur/(params.L_cur - params.H_cur);
                    //     let sigma_33 = (-F[4][2] + F[5][2])/2/params.L_cur/(params.L_cur - params.H_cur);
                    //
                    //     // let sigma_12 = (-F[0][1] + F[1][1])/2/params.L_cur/params.L_cur;
                    //     // let sigma_23 = (-F[2][2] + F[3][2])/2/params.L_cur/(params.L_cur - params.H_cur);
                    //     // let sigma_31 = (-F[4][0] + F[5][0])/2/params.L_cur/(params.L_cur - params.H_cur);
                    //
                    //     // if ( params.dimension == 4 ) { sigma_44 = (-F[6][3] + F[7][3])/2/params.L_cur/(params.L_cur - params.H_cur);}
                    //
                    //     pressure = (sigma_11 + sigma_22 + sigma_33)/3.;
                    //     shear = sigma_33 - pressure;
                    // }

                    S.cg_param_read_timestep(0) ;
                    S.cg_process_timestep(0,false) ;
                    var grid = S.cg_get_gridinfo();
                    density=S.cg_get_result(0, "RHO", 0)[0] ;
                    // vavg=S.cg_get_result(0, "VAVG", 1)[0] ;
                    stressTcxx=S.cg_get_result(0, "TC", 0)[0] ;
                    stressTcyy=S.cg_get_result(0, "TC", 4)[0] ;
                    stressTczz=S.cg_get_result(0, "TC", 8)[0] ;
                    stressTcxy=S.cg_get_result(0, "TC", 1)[0] ;

                    pressure = (stressTcxx+stressTcyy+stressTczz)/3./1e3 ;
                    shear = -stressTcxy/1e3 ;

                }

                // update the picking ray with the camera and mouse position
            	raycaster.setFromCamera( mouse, camera );


                const intersects = raycaster.intersectObjects( spheres.children );
				if ( intersects.length > 0 ) { // if found something
					if ( INTERSECTED != intersects[ 0 ].object ) { // if not the same as last time
                            if ( INTERSECTED !== null ) { INTERSECTED.material.uniforms.ambient.value = 1.0; }
    						INTERSECTED = intersects[ 0 ].object;
                            INTERSECTED.material.uniforms.ambient.value = 5.0;
					}
				}
                else { // didn't find anything
					if ( INTERSECTED !== null ) { // there was something before
                        INTERSECTED.material.uniforms.ambient.value = 1.0;
                        INTERSECTED = null;
                    }
				}


				renderer.render( scene, camera );

				if ( stats !== undefined ) { stats.update(); }

                old_time = new_time;

			}
            // function refresh_simulation() {
            //     // update_L();
            //     // console.log(L)
            //     var range = 0.8*(L/2 - radius);
            //     for ( let i = 0; i < params.N; i ++ ) {
            //         position.set( range*(2*Math.random() - 1), range*(2*Math.random() - 1), range*(2*Math.random() - 1) );
    		// 		physics.setMeshPosition( spheres, position, i );
            //     }
            //     position.set( 0, - L/2 - thickness/2., 0 );
            //
            //     floor.position.y = - L/2 - thickness/2.;
            //     roof.position.y = L/2 + thickness/2.;
            //     left.position.z = - L/2 - thickness/2.;
            //     right.position.z = L/2 + thickness/2.;
            //     back.position.x = L/2 + thickness/2.;
            //     front.position.x = -L/2 - thickness/2.;
            //     camera.position.set( - 3*L, 0, 0 );
            //
            // }

            function add_spheres() {
                radii = S.simu_getRadii();
                spheres = new THREE.Group();
                scene.add(spheres);
                // const material = new THREE.MeshStandardMaterial();


                // const matrix = new THREE.Matrix4();
                const color = new THREE.Color();

                const geometrySphere = new THREE.SphereGeometry( 0.5, Math.pow(2,quality), Math.pow(2,quality) );
                // const geometrySphere = new THREE.BufferGeometry().fromGeometry(
                //   new THREE.SphereGeometry(
                //     1,
                //     Math.pow(2, params.quality),
                //     Math.pow(2, params.quality)
                //   )
                // );
                // spheres = new THREE.InstancedMesh( geometrySphere, material, params.N );
                // spheres.castShadow = true;
                // spheres.receiveShadow = true;
                // scene.add( spheres );

                for ( let i = 0; i < params.N; i ++ ) {
                    const material = NDParticleShader.clone();
                    var object = new THREE.Mesh(geometrySphere, material);
                    object.position.set(0,0,0);
                    object.rotation.z = Math.PI / 2;
                    object.NDDEM_ID = i;
                    spheres.add(object);
                    // spheres.setMatrixAt( i, matrix );
                    // spheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );

                }
            }

            function move_spheres() {
                var x = S.simu_getX();
                var orientation = S.simu_getOrientation();
                if ( params.lut === 'Velocity' ) {
                    v = S.simu_getVelocity();
                }
                else if ( params.lut === 'Rotation Rate' ) {
                    omegaMag = S.simu_getRotationRate();
                }
                else if ( params.lut === 'Force' ) {
                    forceMag = S.simu_getParticleStress(); // NOTE: NOT IMPLEMENTED YET
                }
                for ( let i = 0; i < params.N; i ++ ) {
                    var object = spheres.children[i];

                    // const matrix = new THREE.Matrix4();
                    // matrix.setPosition( x[i][0], x[i][1], x[i][2] );
                    if ( params.dimension == 3 ) {
                        var D_draw = 2*radii[i];
                        object.scale.set(D_draw, D_draw, D_draw);
                    }
                    else if ( params.dimension == 4 ) {
                        var D_draw = 2*Math.sqrt(
                          Math.pow(radii[i], 2) - Math.pow(params.d4_cur - x[i][3], 2)
                        );
                        object.scale.set(D_draw, D_draw, D_draw);
                        // matrix.scale( new THREE.Vector3(D_draw,D_draw,D_draw) );
                    }
                    // spheres.setMatrixAt( i, matrix );
                    object.position.set( x[i][0], x[i][1], x[i][2] );
                    if ( params.lut === 'Velocity' ) {
                        object.material.uniforms.ambient.value = 0.5 + 1e-3*( Math.pow(v[i][0],2) + Math.pow(v[i][1],2) + Math.pow(v[i][2],2) );
                    }
                    if ( params.lut === 'Rotation Rate' ) {
                        // console.log(omegaMag[i])
                        object.material.uniforms.ambient.value = 0.5 + 0.1*omegaMag[i];
                    }
                    for (var j = 0; j < params.N - 3; j++) {
                      object.material.uniforms.xview.value[j] =
                        params.d4_cur;
                      object.material.uniforms.xpart.value[j] =
                        x[i][j + 3];
                    }
                    object.material.uniforms.A.value = orientation[i];
                    // if (params.dimension > 3) {
                    //   object.material.uniforms.x4p.value = x[i][j + 3];
                    //   object.material.uniforms.x4.value = params.d4_cur;
                    // } else {
                    //   object.material.uniforms.x4p.value = 0.0;
                    // }
                }
                // spheres.instanceMatrix.needsUpdate = true;
                // console.log(orientation[0])
            }

            async function NDDEMPhysics() {

            	if ( 'DEMCGND' in window === false ) {

            		console.error( 'NDDEMPhysics: Couldn\'t find DEMCGND.js' );
            		return;

            	}

            	NDDEMCGLib = await DEMCGND(); // eslint-disable-line no-undef

                if ( params.dimension == 3 ) {
                    S = await new NDDEMCGLib.DEMCGND (params.N);
                    finish_setup();
                }
                else if ( params.dimension > 3 ) {
                    console.log( 'N>3 not implemented yet')
                    // S = await new NDDEMLib.Simulation4 (params.N);
                    // finish_setup();
                }



                function finish_setup() {
                    S.simu_interpret_command("dimensions " + String(params.dimension) + " " + String(params.N));
                    S.simu_interpret_command("radius -1 0.5");
                    S.simu_interpret_command("mass -1 1");
                    S.simu_interpret_command("auto rho");
                    S.simu_interpret_command("auto radius uniform "+params.r_min+" "+params.r_max);
                    S.simu_interpret_command("auto mass");
                    S.simu_interpret_command("auto inertia");

                    S.simu_interpret_command("boundary 0 WALL -"+String(params.L)+" "+String(params.L));
                    S.simu_interpret_command("boundary 1 WALL -"+String(params.L)+" "+String(params.L));
                    S.simu_interpret_command("boundary 2 WALL -"+String(params.L)+" "+String(params.L));
                    if ( params.dimension == 3 ) {
                        S.simu_interpret_command("gravity 0 0 0")
                    }
                    if ( params.dimension == 4 ) {
                        S.simu_interpret_command("boundary 3 WALL -"+String(params.L)+" "+String(params.L));
                        S.simu_interpret_command("gravity 0 0 0 -10")
                    }

                    // S.simu_interpret_command("auto location randomsquare");
                    S.simu_interpret_command("auto location randomdrop");

                    S.simu_interpret_command("set Kn 2e5");
                    S.simu_interpret_command("set Kt 8e4");
                    S.simu_interpret_command("set GammaN 75");
                    S.simu_interpret_command("set GammaT 75");
                    S.simu_interpret_command("set Mu 0.5");
                    S.simu_interpret_command("set T 150");
                    S.simu_interpret_command("set dt 0.0001");
                    S.simu_interpret_command("set tdump 10"); // how often to calculate wall forces
                    S.simu_interpret_command("auto skin");
                    S.simu_finalise_init () ;

                    var cgparam ={} ;
                    cgparam["file"]=[{"filename":"none", "content": "particles", "format":"interactive", "number":1}] ;
                    cgparam["boxes"]=[1,1,1] ;
                    // cgparam["boundaries"]=[[-params.L,-params.L,-params.L],[params.L,params.L,params.L]] ;
                    cgparam["boundaries"]=[
                        [-params.L+params.r_max,-params.L+params.r_max,-params.L+params.r_max],
                        [ params.L-params.r_max, params.L-params.r_max, params.L-params.r_max]] ;
                    cgparam["window size"]=2 ;
                    cgparam["skip"]=0;
                    cgparam["max time"]=1 ;
                    cgparam["time average"]="None" ;
                    cgparam["fields"]=["RHO", "VAVG", "TC"] ;
                    cgparam["periodicity"]=[true,true,true];
                    cgparam["window"]="Lucy3D";
                    cgparam["dimension"]=3;


                    console.log(JSON.stringify(cgparam)) ;
                    S.cg_param_from_json_string(JSON.stringify(cgparam)) ;
                    S.cg_setup_CG() ;
                }
            }

            function update_graph() {
                density = params.packing_fraction; //*material_density;
                pressure_time.push(pressure);
                shear_time.push(shear);
                density_time.push(density);

                // if (( Math.abs((pressure_time[pressure_time.length - 2] - pressure )/pressure) > 1e-2 ) || ( Math.abs((shear_time[shear_time.length - 2] - shear )/shear) > 1e-2 ) || ( Math.abs((density_time[density_time.length - 2] - density )/density) > 1e-2 )) {
                    Plotly.extendTraces('stats', {
                        'x': [[pressure]],
                        'y': [[density]],
                        'z': [[shear]],
                    }, [-1])
                // }
            }

            function make_graph() {
                var data = [{
                              type: 'scatter3d',
                              mode: 'lines',
                              x: [],
                              y: [],
                              z: [],
                              name: 'Load path 1',
                              // opacity: 1,
                              line: {
                                width: 5,
                                color: "black",
                                // reversescale: false
                              }
                            }]
                var layout = {
                                  // height: 300,
                                  // width: 500,
                                  xaxis: {
                                    // linecolor: 'white',
                                    autotick: true,
                                    autorange: true,
                                    automargin: true,
                                },
                                  yaxis: {
                                    // linecolor: 'white',
                                    autotick: true,
                                    autorange: true,
                                    automargin: true,
                                },
                                  zaxis: {
                                    // linecolor: 'white',
                                    autotick: true,
                                    autorange: true,
                                    automargin: true,
                                },
                                scene: {
                            		xaxis:{title: 'Pressure p (kPa)'},
                            		yaxis:{title: 'Solids fraction'},// (kg/m<sup>3</sup>)'},
                            		zaxis:{title: 'Deviatoric stress q (kPa)'},
                                aspectmode: 'auto',
                            		},
                                // paper_bgcolor: 'rgba(0,0,0,1)',
                                // plot_bgcolor: 'rgba(0,0,0,1)',
                                margin: {
                                    t: 20, //top margin
                                    l: 20, //left margin
                                    r: 20, //right margin
                                    b: 40 //bottom margin
                                },
                                legend: {
                                    x: 1,
                                    xanchor: 'right',
                                    y: 1
                                  }
                                }
                Plotly.newPlot('stats', data, layout);
            }

            document.getElementById ("download_tag").addEventListener ("click", download_data, false);
            document.getElementById ("stats").addEventListener ("mouseenter",
                () => {
                    document.getElementById("download_tag").classList.remove("hidden")
                    document.getElementById("download_tag").classList.add("visible")
            }, false);
            document.getElementById ("stats").addEventListener ("mouseleave",
                () => {
                    document.getElementById("download_tag").classList.add("hidden")
                    document.getElementById("download_tag").classList.remove("visible")
            }, false);

            function download_data() {
                let gd = document.getElementById('stats')
                let data = gd.data;
                let header = 'Density (kg/m3),Deviatoric stress (Pa),Pressure (Pa)\n';
                let csv = '';
                data.forEach( trace => {
                    csv = csv + header + trace.x.map((el, i) => [el, trace.y[i],trace.z[i]].join(",")).join('\n') + '\n'
                    });
                var link = document.getElementById("download_tag");
                link.setAttribute("href", encodeURI("data:text/csv;charset=utf-8,"+csv));
            }
		</script>
	</body>
</html>

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>NDDEM</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="../node_modules/three/build/three.js"></script>
        <script src="../node_modules/three/examples/js/WebGL.js"></script>
        <script src="../node_modules/three/examples/js/controls/TrackballControls.js"></script>
        <script src="../node_modules/three/examples/js/controls/OrbitControls.js"></script>
        <script src="../node_modules/three/examples/js/libs/dat.gui.min.js"></script>
        <script src="../js/CCapture.all.min.js"></script>
        <script type="x-shader/x-vertex" id="vertexshader">

			uniform float omega1;
            uniform float omega2;
            uniform float omega3;
            uniform float omega4;
            uniform float omega5;
            uniform float omega6;
            uniform float d4;
            uniform float d5;
			// attribute vec3 orientation;
			varying vec3 vColor;
            varying vec3 vNormal;

			void main() {
                vNormal = normal; // for directional lighting
                const float N_lines = 20.0;
                const float pi = 3.14159265359;
                const float two_pi = 6.28318530718;
                // get 3d locations in x,y,z
                const float R = 1.0;
                float x = R*cos((uv.y-0.5)*pi)*cos((uv.x-0.5)*2.0*pi);
                float y = R*cos((uv.y-0.5)*pi)*sin((uv.x-0.5)*2.0*pi);
                float z = R*sin((uv.y-0.5)*pi);

                // compute the rotated location by doing transpose(A) * x, with A the orientation matrix from the dumps
                float x_unrotated = cos(omega1)*cos(omega2)*x + sin(omega1)*cos(omega2)*y - sin(omega2)*z;
                float y_unrotated = (cos(omega1)*sin(omega2)*sin(omega3) - sin(omega1)*cos(omega3))*x + (sin(omega1)*sin(omega2)*sin(omega3) + cos(omega1)*cos(omega3))*y + cos(omega2)*sin(omega3)*z;
                float z_unrotated = (cos(omega1)*sin(omega2)*cos(omega3) + sin(omega1)*sin(omega3))*x + (sin(omega1)*sin(omega2)*cos(omega3) - cos(omega1)*sin(omega3))*y + cos(omega2)*cos(omega3)*z;
                // convert that new vector in hyperspherical coordinates (you can have a look at the hyperspherical_xtophi function in Tools.h)

                // color according to the hyperspherical coordinates (cf. the phi2color function in Texturing.cpp)



                // float phi =
                vColor.r = pow(sin(x_unrotated*N_lines),2.0);
                vColor.g = pow(cos(y_unrotated*N_lines),2.0);
                // vColor.r = x;
                // vColor.g = y;
                // vColor.b = z;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			varying vec3 vNormal;
			varying vec3 vColor;

			void main() {

				const float ambient = 1.0;

                // add directional lighting
				// vec3 light = vec3( 1.0 );
				// light = normalize( light );
				// float directional = max( dot( vNormal, light ), 0.0 );
				// gl_FragColor = vec4( ( ambient + directional ) * vColor, 1.0 ); // colours by vertex colour

                gl_FragColor = vec4( ( ambient ) * vColor, 1.0 ); // colours by vertex colour

			}

		</script>
        <script>

        var root_dir = 'http://localhost:54321/';
        if ( window.location.hostname.includes('benjymarks') ) { root_dir = 'http://www.benjymarks.com/nddem/'}
        else if ( window.location.hostname.includes('github') ) { root_dir = 'https://franzzzzzzzz.github.io/NDDEM/'; cache=true; }

        var fname = "visualise/resources/earthmap.jpg";

        const urlParams = new URLSearchParams(window.location.search);
        const recorder = new CCapture({
        	verbose: true,
        	display: true,
        	framerate: 30,
        	quality: 100,
        	format: 'png',
        	timeLimit: 100,
        	frameLimit: 0,
        	autoSaveTime: 0
        });
        var record = false; var quality = 7;
        var slice = {'omega1':0,'omega2':0,'omega3':0}
        if ( urlParams.has('fname') ) { fname = urlParams.get('fname'); };
        if ( urlParams.has('quality') ) { quality = parseInt(urlParams.get('quality'))}
        clock = new THREE.Clock();
        var scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x111111 );
		var camera = new THREE.PerspectiveCamera( 50, window.innerWidth/window.innerHeight, 0.1, 1000 );
		camera.position.z = 6;

		var renderer = new THREE.WebGLRenderer();
        if ( urlParams.has('controls') ) { var controls = new THREE.TrackballControls( camera, renderer.domElement ); }
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

        var background_light = new THREE.AmbientLight( 0xffffff );
        scene.add( background_light );
        var light = new THREE.DirectionalLight(0x505050);
        light.position.x = -2
        light.position.z = 2
        scene.add( light );

        var sphere;
        var rect;

        var uniforms = {
            omega1: {value: 0.0},
            omega2: {value: 0.0},
            omega3: {value: 0.0},
            omega4: {value: 0.0},
            omega5: {value: 0.0},
            omega6: {value: 0.0},
			d4: { value: 0.0 },
            d5: { value: 0.0 },
		};
        var rect_geometry = new THREE.PlaneBufferGeometry( 1, 1, Math.pow(2,quality), Math.pow(2,quality) );
        sphere_geometry = new THREE.BufferGeometry().fromGeometry( new THREE.SphereGeometry( 1, Math.pow(2,quality), Math.pow(2,quality) ) );

        var numFaces = sphere_geometry.attributes.position.count / 3;
        // var colors = new Float32Array( numFaces * 3 * 3 );
        // var color = new THREE.Color();

        // sphere_geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) ); // NOTE: THIS FUNCTION CHANGES NAME IN THREEJS v110 TO setAttribute!!!!!
        // rect_geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );

        var shaderMaterial = new THREE.ShaderMaterial( {
			uniforms: uniforms,
			vertexShader: document.getElementById( 'vertexshader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader' ).textContent
		} );

        sphere = new THREE.Mesh( sphere_geometry, shaderMaterial );
        rect = new THREE.Mesh( rect_geometry, shaderMaterial );
        sphere.position.x = -2
        rect.position.x = 2
        rect.scale.set(4,2,1);
        // sphere.rotation.y = Math.PI/2.;

        scene.add( sphere );
        scene.add( rect );

        var gui = new dat.GUI();
        gui.add( slice, 'omega1').min(-1).max(1).step(0.01).listen().name('Omega 1 rate') ;
        gui.add( slice, 'omega2').min(-1).max(1).step(0.01).listen().name('Omega 2 rate') ;
        gui.add( slice, 'omega3').min(-1).max(1).step(0.01).listen().name('Omega 3 rate') ;
        gui.open();

        if ( urlParams.has('record') ) { addRecordOnKeypress() };

        function addRecordOnKeypress() {
            document.addEventListener("keydown", function(event) {
                if (event.code == 'Space') {
                    if (record) {
                        recorder.stop();
                        recorder.save();
                    }
                    else {
                        recorder.start();
                    }
                    record = !record;
                }
            }, false);
        }

		var animate = function () {
            if ( urlParams.has('controls') ) { controls.update(); }
            var delta = clock.getDelta()
            uniforms.omega1.value += slice.omega1*delta;
            uniforms.omega2.value += slice.omega2*delta;
            uniforms.omega3.value += slice.omega3*delta;
            // console.log(uniforms.omega1.value);
			requestAnimationFrame( animate );
			renderer.render( scene, camera );
            if ( record ) {
                recorder.capture(renderer.domElement);
            }

		};
        window.addEventListener( 'resize', onWindowResize, false );
		animate();

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            if ( controls !== undefined ) { controls.handleResize(); }
        };
        </script>

	</body>
</html>

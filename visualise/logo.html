<html lang="en">
	<head>
		<title>NDDEM logo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
				body {
					color: #e72564;
					font-family:Montserrat;
					font-size:26px;
					text-align:center;

					background-color: #111111;
					margin: 0px;
					overflow: hidden;
				}
                div.content{ width: 900px }
		</style>
	</head>
	<body>
	<div id="container" class="content"><br /><br /><br /><br /><br />Loading...</div>
    <script src="https://gitcdn.xyz/repo/mrdoob/three.js/dev/build/three.js"></script>
    <!-- <script src="https://gitcdn.xyz/repo/mrdoob/three.js/dev/examples/js/libs/ammo.js"></script> -->
    <script src="https://raw.githack.com/benjym/CIVL5999/master/ammo.js"></script>
    <script src="https://gitcdn.xyz/repo/mrdoob/three.js/dev/examples/js/WebGL.js"></script>
    <script src="https://gitcdn.xyz/repo/mrdoob/three.js/dev/examples/js/loaders/GLTFLoader.js"></script>

	<!-- <script src="node_modules/three/build/three.js"></script>
	<script src="node_modules/three/examples/js/libs/ammo.js"></script>
	<script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
	<script src="node_modules/three/examples/js/WebGL.js"></script>
    <script src="node_modules/three/examples/js/loaders/GLTFLoader.js"></script> -->

	<script>
		if ( WEBGL.isWebGLAvailable() === false ) {

			document.body.appendChild( WEBGL.getWebGLErrorMessage() );
			document.getElementById( 'container' ).innerHTML = "";

		}

		// Graphics variables
		var container, stats;
		var camera, controls, scene, renderer;
		var textureLoader;
		var clock = new THREE.Clock();

		// Physics variables
		var gravityConstant = - 9.8;
		var collisionConfiguration;
		var dispatcher;
		var broadphase;
		var solver;
		var softBodySolver;
		var physicsWorld;
		var rigidBodies = [];
		var margin = 0.01;
		var rope;

		var armMovement = 0;
        var ropes = [];
		var ballRadius = 0.1;

        init();
		animate();

		function init() {
			initGraphics();
			initPhysics();
			createObjects();
		}

		function initGraphics() {
			container = document.getElementById( 'container' );
			camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );
			scene = new THREE.Scene();
            // var axesHelper = new THREE.AxesHelper( 5 );
            // scene.add( axesHelper );
			scene.background = new THREE.Color( 0x111111 ); // revealjs background
            // scene.background = new THREE.Color( 0xe72564 ); // pink background

			camera.position.set( -3, -1, 3 );
            camera.rotation.z = 3.*Math.PI/4;
            camera.up.set(-1,-1,0);
            camera.lookAt(-0,-0,0);
			// controls = new THREE.OrbitControls( camera );
			// controls.target.set( 0, 0, 0 );
			// controls.update();

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;

			textureLoader = new THREE.TextureLoader();

			var ambientLight = new THREE.AmbientLight( 0xaaaaaa );
			scene.add( ambientLight );

			var light = new THREE.DirectionalLight( 0xffffff, 1 );
			light.position.set( - 10, 0, 5 );
			light.castShadow = true;
			light.shadow.mapSize.x = 2048;
			light.shadow.mapSize.y = 2048;

            scene.add( light );

            var light = new THREE.AmbientLight( 0x404040 ); // soft white light
            scene.add( light );

			container.innerHTML = "";

			container.appendChild( renderer.domElement );
            //
			// stats = new Stats();
			// stats.domElement.style.position = 'absolute';
			// stats.domElement.style.top = '0px';
			// container.appendChild( stats.domElement );

			window.addEventListener( 'resize', onWindowResize, false );

            new THREE.GLTFLoader()
                // .setPath( 'http://localhost:8000/visualise/resources/' )
                .load( 'https://rawcdn.githack.com/benjym/CIVL5999/9d29107b940c23142a4f1b7499d6c8d2d9a81bce/Earth.glb', // resource URL
            	   function ( gltf ) {
                        var s = 0.000005;
                        var model = gltf.scene;
                        model.scale.set(s,s,s);
                        model.position.x = 0.5
                        model.position.y = -0.4
                        model.position.z = 2.2
                        model.rotation.x = 0.1;
                        scene.add( model );
            	       },
                   undefined,
                   function (err) {console.log(err);});

		}

		function initPhysics() {

			// Physics configuration

			collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
			dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
			broadphase = new Ammo.btDbvtBroadphase();
			solver = new Ammo.btSequentialImpulseConstraintSolver();
			softBodySolver = new Ammo.btDefaultSoftBodySolver();
			physicsWorld = new Ammo.btSoftRigidDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration, softBodySolver );
			physicsWorld.setGravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );
			physicsWorld.getWorldInfo().set_m_gravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );

		}

		function createObjects() {

			var pos = new THREE.Vector3();
			var quat = new THREE.Quaternion();

			// Balls
            var numballs = 50
            var balls = [];

            var ballMass = 0.1;
			var ropeNumSegments = 10;
			var ropeLength = 1.5;
			var ropeMass = 0.1;

			var base_ball = new THREE.Mesh( new THREE.SphereBufferGeometry( ballRadius, 20, 20 ), new THREE.MeshPhongMaterial( { color: 0xe72564 } ) );
			base_ball.castShadow = true;
			base_ball.receiveShadow = true;

            for ( n=0;n<numballs;n++ ) {
                var ballShape = new Ammo.btSphereShape( ballRadius );
    			// ballShape.setMargin( 10000*margin );

                ball = base_ball.clone()
                var x = ropeLength/3.*Math.random();
                var z = ropeLength/3.*Math.random();
                var y = - ropeLength + Math.sqrt(Math.pow(x,2) + Math.pow(z,2)) //+ 0.01*(Math.random() - 0.5)
                pos.set( x,y,z );
                quat.set( 0, 0, 0, 1 );
                createRigidBody( ball, ballShape, ballMass, pos, quat );
                ball.userData.physicsBody.setFriction( 0.5 );
                ball.phi = Math.random()*Math.PI*2.;
                balls.push(ball);

                var ropePos = ball.position.clone();
    			ropePos.y += ballRadius;

    			var segmentLength = ropeLength / ropeNumSegments;
    			var ropeGeometry = new THREE.BufferGeometry();
    			// var ropeMaterial = new THREE.MeshStandardMaterial( { color: 0xe72564 } );
                var ropeMaterial = new THREE.LineBasicMaterial( { color: 0xD2275D } );
    			var ropePositions = [];
    			var ropeIndices = [];

    			for ( var i = 0; i < ropeNumSegments + 1; i ++ ) {
                    ropePositions.push( i*ropePos.x/ropeNumSegments,
                                        i*ropePos.y/ropeNumSegments,
                                        i*ropePos.z/ropeNumSegments
                                      );
                }
    			for ( var i = 0; i < ropeNumSegments; i ++ ) { ropeIndices.push( i, i + 1 ); }

    			ropeGeometry.setIndex( new THREE.BufferAttribute( new Uint16Array( ropeIndices ), 1 ) );
    			ropeGeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( ropePositions ), 3 ) );
    			ropeGeometry.computeBoundingSphere();
    			rope = new THREE.LineSegments( ropeGeometry, ropeMaterial );
    			rope.castShadow = true;
    			rope.receiveShadow = true;
    			scene.add( rope );


    			// Rope physic object
    			var softBodyHelpers = new Ammo.btSoftBodyHelpers();
                var ropeStart = new Ammo.btVector3( 0., 0., 0. );
    			var ropeEnd = new Ammo.btVector3( ropePos.x, ropePos.y, ropePos.z );
    			var ropeSoftBody = softBodyHelpers.CreateRope( physicsWorld.getWorldInfo(), ropeStart, ropeEnd, ropeNumSegments - 1, 0 );
    			var sbConfig = ropeSoftBody.get_m_cfg();
                sbConfig.set_kDF( 0.1 ); // friction
                sbConfig.set_kDP( 0.5 ); // Damping
                // sbConfig.set_kPR( pressure ); // pressure
    			sbConfig.set_viterations( 10 );
    			sbConfig.set_piterations( 10 );

    			ropeSoftBody.setTotalMass( ropeMass, false );
    			Ammo.castObject( ropeSoftBody, Ammo.btCollisionObject ).getCollisionShape().setMargin( margin * 3 );
    			physicsWorld.addSoftBody( ropeSoftBody, 1, - 1 );
    			rope.userData.physicsBody = ropeSoftBody;
    			// Disable deactivation
    			ropeSoftBody.setActivationState( 4 );

    			// The base
    			var armMass = 0;
    			var baseMaterial = new THREE.MeshPhongMaterial( { color: 0x606060 } );
    			quat.set( 0, 0, 0, 1 );

    			pos.set( -0.05, -0.05, -0.05 );
    			var arm = createParalellepiped( 0.1, 0.1, 0.1, armMass, pos, quat, baseMaterial );
                arm.visible = false;
    			// arm.castShadow = true;
    			// arm.receiveShadow = true;

    			// Glue the rope extremes to the ball and the arm
    			var influence = 1;
    			ropeSoftBody.appendAnchor( 0, arm.userData.physicsBody, true, influence );
                ropeSoftBody.appendAnchor( ropeNumSegments, ball.userData.physicsBody, true, influence );

                ropes.push( rope );
            }
		}

		function createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {

			var threeObject = new THREE.Mesh( new THREE.BoxBufferGeometry( sx, sy, sz, 1, 1, 1 ), material );
			var shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
			shape.setMargin( margin );

			createRigidBody( threeObject, shape, mass, pos, quat );

			return threeObject;

		}

		function createRigidBody( threeObject, physicsShape, mass, pos, quat ) {

			threeObject.position.copy( pos );
			threeObject.quaternion.copy( quat );

			var transform = new Ammo.btTransform();
			transform.setIdentity();
			transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
			transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
			var motionState = new Ammo.btDefaultMotionState( transform );

			var localInertia = new Ammo.btVector3( 0, 0, 0 );
			physicsShape.calculateLocalInertia( mass, localInertia );

			var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
			var body = new Ammo.btRigidBody( rbInfo );

			threeObject.userData.physicsBody = body;

			scene.add( threeObject );

			if ( mass > 0 ) {

				rigidBodies.push( threeObject );

				// Disable deactivation
				body.setActivationState( 4 );

			}

			physicsWorld.addRigidBody( body );

		}

		function createRandomColor() {

			return Math.floor( Math.random() * ( 1 << 24 ) );

		}

		function createMaterial() {

			return new THREE.MeshPhongMaterial( { color: createRandomColor() } );

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
            camera.lookAt(0,0,0);
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );

		}

		function animate() {

			requestAnimationFrame( animate );

			render();
			// stats.update();

		}

		function render() {

			var deltaTime = clock.getDelta();
            updateSizes( clock.elapsedTime );
			updatePhysics( deltaTime );

			renderer.render( scene, camera );

		}

        function updateSizes( t ) {
            // cycle gravity direction
            const theta = Math.cos(t/2.)/2.;
            const gravity = new Ammo.btVector3( Math.sin(theta)*gravityConstant, Math.cos(theta)*gravityConstant, 0 );
            physicsWorld.setGravity( gravity );
            physicsWorld.getWorldInfo().set_m_gravity( gravity );
            // delete gravity;

            for ( var i = 0, il = rigidBodies.length; i < il; i ++ ) {
                var objThree = rigidBodies[ i ];
                var objPhys = objThree.userData.physicsBody;
                var scale = 1. + Math.sin(t/2. + objThree.phi)/2.;

                // const shape = new Ammo.btSphereShape( ballRadius*scale );
                var scale_vector = new Ammo.btVector3( scale , scale, scale );
                // delete objPhys.getCollisionShape();
                // objPhys.getCollisionShape.__destroy__ = true;
                // console.log(objPhys.getCollisionShape());
    			// objPhys.setCollisionShape( shape ); // WORKS FOR 20 SECONDS
                objPhys.getCollisionShape().setLocalScaling(scale_vector); // WORKS FOR....
                // console.log(objPhys.getCollisionShape().getLocalScaling());
                objThree.scale.set( scale,scale,scale );
                // delete shape;
                // delete scale_vector;

                // Ammo.castObject( objPhys, Ammo.btCollisionObject ).getCollisionShape().setLocalScaling(10.);
                // Ammo.castObject( objPhys, Ammo.btCollisionObject ).getCollisionShape().setLocalScaling( 1000000. ); // REMOVES INTERACTIONS
                // objPhys.getCollisionShape().setMargin( 1000000000. ); // DOES NOTHING
                // Ammo.btCollisionWorld.updateSingleAABB( objPhys ); // doesn't work



            }
            // physicsWorld.setForceUpdateAllAabbs(true);
            physicsWorld.m_forceUpdateAllAabbs = true;
        }

		function updatePhysics( deltaTime ) {


			// Step world
			physicsWorld.stepSimulation( deltaTime, 10 );

			// Update ropes
            for ( var j = 0, il = rigidBodies.length; j < il; j ++ ) {

                var rope = ropes[j]
    			var softBody = rope.userData.physicsBody;
    			var ropePositions = rope.geometry.attributes.position.array;
    			var numVerts = ropePositions.length / 3;
    			var nodes = softBody.get_m_nodes();
    			var indexFloat = 0;
    			for ( var i = 0; i < numVerts; i ++ ) {

    				var node = nodes.at( i );
    				var nodePos = node.get_m_x();
    				ropePositions[ indexFloat ++ ] = nodePos.x();
    				ropePositions[ indexFloat ++ ] = nodePos.y();
    				ropePositions[ indexFloat ++ ] = nodePos.z();

    			}
    			rope.geometry.attributes.position.needsUpdate = true;

				var objThree = rigidBodies[ j ];
				var objPhys = objThree.userData.physicsBody;
				var ms = objPhys.getMotionState();
				if ( ms ) {

                    var transformAux1 = new Ammo.btTransform();
					ms.getWorldTransform( transformAux1 );
					var p = transformAux1.getOrigin();
					var q = transformAux1.getRotation();
					objThree.position.set( p.x(), p.y(), p.z() );
					objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

				}

			}

		}

		</script>

	</body>
</html>

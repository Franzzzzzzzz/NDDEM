<html lang="en">
	<head>
		<title>NDDEM</title>
		<meta charset="utf-8">
        <link rel='icon' href='resources/favicon.ico' type='image/x-icon'/ >
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<!-- Origin Trial Token, feature = WebXR Device API (For Chrome M69+), origin = https://threejs.org, expires = 2019-03-06 -->
		<meta http-equiv="origin-trial" data-feature="WebXR Device API (For Chrome M69+)" data-expires="2019-03-06" content="AvDjbxYpoTgOL1PS0JEra7KFCehfTlKnXpU/ORSwNdCQ35cX70cTUkXOnQ26A5XJi3eXHSKpBPchdt5lbcxDuAIAAABTeyJvcmlnaW4iOiJodHRwczovL3RocmVlanMub3JnOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkRldmljZU02OSIsImV4cGlyeSI6MTU1MTgzMDM5OX0=">
        <style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
            #N_tag {
                color: white;
                padding: 24px;
                font: 48px Montserrat;
                font-weight: bold;
                position:absolute;
            }
		</style>
	</head>
	<body>
		<script src="node_modules/three/build/three.js"></script>
        <script src="node_modules/three/examples/js/WebGL.js"></script>
		<script src="js/WebVR.js"></script>
		<!-- <script src="node_modules/three/examples/js/vr/WebVR.js"></script> -->
        <script src="node_modules/three/examples/js/controls/TrackballControls.js"></script>
        <script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
        <script src="node_modules/three/examples/js/effects/AnaglyphEffect.js"></script>
        <!-- <script src="node_modules/three/examples/js/loaders/VTKLoader.js"></script> -->
        <script src="node_modules/three/examples/js/loaders/LoaderSupport.js"></script>
        <script src="node_modules/three/examples/js/loaders/OBJLoader.js"></script>
		<script src="node_modules/three/examples/js/loaders/MTLLoader.js"></script>
		<!-- <script src="node_modules/three/examples/js/vr/ViveController.js"></script> -->
		<script src="js/VRController.js"></script>
        <script src="node_modules/papaparse/papaparse.js"></script>
        <script src="node_modules/three/examples/js/libs/dat.gui.min.js"></script>
        <!-- <script src="js/datguivr.js"></script> -->
        <script src="node_modules/three/examples/js/math/Lut.js"></script>
        <script src="js/CCapture.all.min.js"></script>
        <script type="x-shader/x-vertex" id="vertexshader-4D">
            uniform int N; // number of dimensions in simulation
            uniform float N_lines; // number of lines to render across particle
			uniform mat4 A;  // orientation matrix for this particle
            uniform float R; // particle radius
            uniform float x4; // loc of viewing position
            uniform float x4p; // loc of centre of particle in D4
			varying vec3 vColor; // colour at vertex (output)
            varying vec3 vNormal; // normal at vertex (output)

            void main() {
                vNormal = normal; // for directional lighting
                const float pi = 3.14159265359;
                float R_draw; // radius particle will be drawn at
                float R_draw_squared = pow(R,2.0)-pow(x4-x4p,2.0);
                if ( R_draw_squared > 0.0 ) { // only if visible
                    R_draw = sqrt(R_draw_squared);
                    vec4 x;
                    vec4 x_rotated;
                    // get 3d locations in x,y,z,w in coord system where center of sphere is at 0,0,0,0
                    x.x = R_draw*cos((uv.y-0.5)*pi)*cos((uv.x-0.5)*2.0*pi);
                    x.y = R_draw*cos((uv.y-0.5)*pi)*sin((uv.x-0.5)*2.0*pi);
                    x.z = R_draw*sin((uv.y-0.5)*pi);
                    x.w = x4p - x4;

                    // compute the rotated location by doing transpose(A) * x, with A the orientation matrix from the dumps
                    x_rotated.x = A[0].x*x.x + A[0].y*x.y + A[0].z*x.z + A[0].w*x.w;
                    x_rotated.y = A[1].x*x.x + A[1].y*x.y + A[1].z*x.z + A[1].w*x.w;
                    x_rotated.z = A[2].x*x.x + A[2].y*x.y + A[2].z*x.z + A[2].w*x.w;
                    x_rotated.w = A[3].x*x.x + A[3].y*x.y + A[3].z*x.z + A[3].w*x.w;

                    // convert that new vector in hyperspherical coordinates (you can have a look at the hyperspherical_xtophi function in Tools.h)
                    // NOTE: STILL PROBABLY NOT RIGHT
                    float rsqr = pow(length(x_rotated),2.0);
                    float phi0 = acos(x_rotated.x/sqrt(rsqr));
                    rsqr = rsqr - x_rotated.x*x_rotated.x;
                    float phi1 = acos(x_rotated.y/sqrt(rsqr));
                    rsqr = rsqr - x_rotated.y*x_rotated.y;
                    float phi2 = acos(x_rotated.z/sqrt(rsqr));
                    // rsqr -= x_rotated.z^2;

                    if ( x_rotated.w < 0.0 ) { phi2 = 2.0*pi - phi2; }

                    vColor.r = abs(sin(phi0*3.));
                    vColor.g = abs(sin(phi1*3.));
                    if ( N > 3 ) {
                        vColor.b = abs(sin(phi2*2.));
                        vColor = vColor * abs(sin(phi2));
                    }
                    vColor = vColor * abs(sin(phi1));
                    // vColor.r = x_rotated.x;
                    // vColor.g = x_rotated.y;
                    // vColor.b = x_rotated.z;

                    // if ( N > 4 ) { rescale(vColor); }
                }
                else { vColor.r = 0.0; }
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
            varying vec3 vNormal;
            varying vec3 vColor;

            void main() {

                // add directional lighting
                const float ambient = 1.0;
                vec3 light = vec3( 1.0 );
                light = normalize( light );
                float directional = max( dot( vNormal, light ), 0.0 );
                gl_FragColor = vec4( ( ambient + directional ) * vColor, 1.0 ); // colours by vertex colour

                // no directional lighting
                // const float ambient = 1.0;
                // gl_FragColor = vec4( ( ambient ) * vColor, 1.0 ); // colours by vertex colour

            }
        </script>
        <script src="js/nddem.js"></script>
	</body>
</html>
